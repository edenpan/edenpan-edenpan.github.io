<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Eden</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="computer, finance, some recording">
<meta property="og:type" content="website">
<meta property="og:title" content="Eden">
<meta property="og:url" content="http://blog.sevenpan.com/index.html">
<meta property="og:site_name" content="Eden">
<meta property="og:description" content="computer, finance, some recording">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Eden">
<meta name="twitter:description" content="computer, finance, some recording">
  
    <link rel="alternate" href="/atom.xml" title="Eden" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Eden</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.sevenpan.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Core_java/Java8 并发指南：线程和执行者 Threads and Executors" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/04/Core_java/Java8 并发指南：线程和执行者 Threads and Executors/" class="article-date">
  <time datetime="2019-03-04T07:12:25.000Z" itemprop="datePublished">2019-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java8-并发指南：线程和执行者-Threads-and-Executors"><a href="#Java8-并发指南：线程和执行者-Threads-and-Executors" class="headerlink" title="Java8 并发指南：线程和执行者 Threads and Executors"></a>Java8 并发指南：线程和执行者 Threads and Executors</h1><p>from： <a href="https://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/" target="_blank" rel="noopener">https://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/</a><br>这个指南主要是教你理解Java8并发编程。一共有三个部分：  </p>
<ol>
<li>线程和执行(Threads and Executors)</li>
<li>同步和锁(Synchronization and Locks)</li>
<li>原子变量和并发map(Atomic Variables and ConcurrentMap)<br>并发编程的API最开始是在JAVA5中被介绍的，之后就不断的逐渐被增强。本文中的主要观点也可以在老java版本中工作。不过代码主要集中在Java8并且使用了lambda表达和其他的一些新特性。如果对lambda不太熟悉可以先阅读<a href="https://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="noopener">https://winterbe.com/posts/2014/03/16/java-8-tutorial/</a>这篇文章。  </li>
</ol>
<h2 id="Threads-和-Runables"><a href="#Threads-和-Runables" class="headerlink" title="Threads 和 Runables"></a>Threads 和 Runables</h2><p>所有的现代操作系统都是通过线程和进程来支持高并发的。进程是程序的实例通常是独立运行的。而线程是用来并发执行程序的，这样我们可以最大程度的利用CPU。<br>Java从JDK1.0开始支持线程。</p>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>并发的API介绍了一个ExecutorService的概念作为一个高层级的替代来和Threads直接进行工作。Executors可以运行匿名方法和管理一个线程池，所以我们无须手动创造线程。在线程池中的所有线程将会被通过钩子函数来复用，所以我们可以运行任意多的并发任务在我们的应用的生命周期中通过一个executor服务。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    String threadName = Thread.currentThread().getName();</span><br><span class="line">    System.out.println(&quot;Hello &quot; + threadName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>看起来运行的和之前的Threads和Runables结果差不多，但是在这个例子中，这个Java进程从来不会停止。Executors需要被显示的停止，否则她们将会继续监听新的线程。<br>一个ExecutorService提供两个方法来关闭：shutdown()等待当前任务执行结束，然后停止。shutdownNow()终止所有运行的任务，并且立刻停止executor。<br>通常用来停止线程池的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;attempt to shutdown executor&quot;);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">    executor.awaitTermination(5, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">catch (InterruptedException e) &#123;</span><br><span class="line">    System.err.println(&quot;tasks interrupted&quot;);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">    if (!executor.isTerminated()) &#123;</span><br><span class="line">        System.err.println(&quot;cancel non-finished tasks&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdownNow();</span><br><span class="line">    System.out.println(&quot;shutdown finished&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Callables-和-Futures"><a href="#Callables-和-Futures" class="headerlink" title="Callables 和 Futures"></a>Callables 和 Futures</h2><p>除了Runnable，executors也支持另外一种类型任务：Callable。Callable是和Runnable一样的函数接口，但是函数返回值不是空值。<br>Callable可以提交给线程池就像是Runnable一样。但是submit()并不会等待任务的完成，executor并不能直接返回callable的结果。Future替换了executor来获取真实的返回值在之后的时间点。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(1);</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;future done? &quot; + future.isDone());</span><br><span class="line"></span><br><span class="line">Integer result = future.get();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;future done? &quot; + future.isDone());</span><br><span class="line">System.out.print(&quot;result: &quot; + result);</span><br></pre></td></tr></table></figure>
<pre><code>future done? false
future done? true
result: 123
</code></pre><p>Futures和底层的线程池服务是耦合的。如果在future还没运行完毕的时候，你关闭了线程池，将会有异常抛出。  </p>
<h2 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h2><p>调用future.get()时，会阻塞线程直到返回，也可以在get上加timeout的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(1);</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (InterruptedException e) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;task interrupted&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">future.get(1, TimeUnit.SECONDS);</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">## InvokeAll</span><br><span class="line">Executor支持一次批量提交多个callables通过invokeAll()。这个方法接受了一个callable的集合并且放回futures的list。</span><br></pre></td></tr></table></figure>
<p>ExecutorService executor = Executors.newWorkStealingPool();</p>
<p>List&lt;Callable<string>&gt; callables = Arrays.asList(<br>        () -&gt; “task1”,<br>        () -&gt; “task2”,<br>        () -&gt; “task3”);</string></p>
<p>executor.invokeAll(callables)<br>    .stream()<br>    .map(future -&gt; {<br>        try {<br>            return future.get();<br>        }<br>        catch (Exception e) {<br>            throw new IllegalStateException(e);<br>        }<br>    })<br>    .forEach(System.out::println);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## InvokeAny</span><br><span class="line">另外一种批量提交callable的方式是invokeAny()，工作的方式和invokeAll有所不同。不同于返回future对象，这个方法在第一次调用终止前会阻塞并且放回callable的结果。  </span><br><span class="line">为了测试这个行为，代码如下，这个方法在返回值之前会睡眠一段时间，然后我们使用一系列的不同返回时间的callable并且通过invokeAny()进行调用。</span><br></pre></td></tr></table></figure></p>
<p>Callable<string> callable(String result, long sleepSeconds) {<br>    return () -&gt; {<br>        TimeUnit.SECONDS.sleep(sleepSeconds);<br>        return result;<br>    };<br>}</string></p>
<p>ExecutorService executor = Executors.newWorkStealingPool();</p>
<p>List&lt;Callable<string>&gt; callables = Arrays.asList(<br>    callable(“task1”, 2),<br>    callable(“task2”, 1),<br>    callable(“task3”, 3));</string></p>
<p>String result = executor.invokeAny(callables);<br>System.out.println(result);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">上述代码中使用了另外一种executor叫做newWorkStealingPool，这个工厂方法是Java8中的一种，并且返回一种ForkJoinPool的executor。不同于使用的是固定大小的线程池，ForkJoinPools被创建给一个和当前hostsCPU数量相同的数量的线程池。  </span><br><span class="line"></span><br><span class="line">## Scheduled Executors</span><br><span class="line">在学会了如何通过executor一次提交并且运行任务，为了可以周期性的多次运行任务，我们可以利用计划的线程池。  </span><br><span class="line">一个ScheduledExecutorService是一种可以计划任务来运行不管是周期性的还是只是运行一次。  </span><br><span class="line"></span><br><span class="line">如下代码是在三秒延迟之后运行任务。</span><br></pre></td></tr></table></figure>
<p>ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);</p>
<p>Runnable task = () -&gt; System.out.println(“Scheduling: “ + System.nanoTime());<br>ScheduledFuture&lt;?&gt; future = executor.schedule(task, 3, TimeUnit.SECONDS);</p>
<p>TimeUnit.MILLISECONDS.sleep(1337);</p>
<p>long remainingDelay = future.getDelay(TimeUnit.MILLISECONDS);<br>System.out.printf(“Remaining Delay: %sms”, remainingDelay);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFuture有一个方法getDelay()来获取剩下的延迟时间。直到延迟结束，这个任务将会被并发。  </span><br><span class="line">为了让任务可以周期性执行，executors提供了两个方法：scheduleAtFixedRate(), scheduleWithFixedDelay()。FixedRate是不考虑任务运行时间的，比如如果间隔是1s而任务要运行2s那么这个任务会很快不断运行。而FixedDelay则是考虑的是任务结束和下一个任务开始之间的间隔的。</span><br></pre></td></tr></table></figure></p>
<p>ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);</p>
<p>Runnable task = () -&gt; System.out.println(“Scheduling: “ + System.nanoTime());</p>
<p>int initialDelay = 0;<br>int period = 1;<br>executor.scheduleAtFixedRate(task, initialDelay, period, TimeUnit.SECONDS);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);</p>
<p>Runnable task = () -&gt; {<br>    try {<br>        TimeUnit.SECONDS.sleep(2);<br>        System.out.println(“Scheduling: “ + System.nanoTime());<br>    }<br>    catch (InterruptedException e) {<br>        System.err.println(“task interrupted”);<br>    }<br>};</p>
<p>executor.scheduleWithFixedDelay(task, 0, 1, TimeUnit.SECONDS);<br><code>`</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.sevenpan.com/2019/03/04/Core_java/Java8 并发指南：线程和执行者 Threads and Executors/" data-id="cjswzmq0b000846rruq7xtsug" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基础建设和杂项比较/DevOps 笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/03/基础建设和杂项比较/DevOps 笔记/" class="article-date">
  <time datetime="2019-02-03T07:43:16.000Z" itemprop="datePublished">2019-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>找了一个关于devops的文章，想看看详细的实践是怎么做的。<br>from: <a href="https://medium.com/@devfire" target="_blank" rel="noopener">https://medium.com/@devfire</a><br> <a href="https://medium.com/@devfire/how-to-become-a-devops-engineer-in-six-months-or-less-part-2-configure-a2dfc11f6f7d" target="_blank" rel="noopener">https://medium.com/@devfire/how-to-become-a-devops-engineer-in-six-months-or-less-part-2-configure-a2dfc11f6f7d</a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><a href="https://medium.com/@devfire/how-to-become-a-devops-engineer-in-six-months-or-less-366097df7737" target="_blank" rel="noopener">https://medium.com/@devfire/how-to-become-a-devops-engineer-in-six-months-or-less-366097df7737</a><br>基础列的就是三部分:Linux, Python 以及 AWS.<br>然后六个部分：  </p>
<pre><code>configure配置：Terraform - Ansible
Version版本：Git+GitHub - GitLab
package包:Docker - Lambda
Deploy部署:Jenkins - codeDeploy 
Run运行:ECS - Kubernetes
Monitoer监控：ELK Stack - Prometheus
</code></pre><h2 id="configure-配置"><a href="#configure-配置" class="headerlink" title="configure 配置"></a>configure 配置</h2><p><a href="https://medium.com/@devfire/how-to-become-a-devops-engineer-in-six-months-or-less-part-2-configure-a2dfc11f6f7d" target="_blank" rel="noopener">https://medium.com/@devfire/how-to-become-a-devops-engineer-in-six-months-or-less-part-2-configure-a2dfc11f6f7d</a><br>配置就是将机器配置好基础设施来让代码运行。以前的话可能是一步一步的安装，而新的方法是将基础设施也编码(infrastructure-as-code).这也是这个阶段需要做的事情。<br><em>作为最佳实践，基础设施作为代码要求提供计算资源所需的任何工作都必须通过代码来完成。</em><br>计算资源是指：计算，存储，网络，数据库等等。<br>在Devops中，我们将会：</p>
<ol>
<li>在<a href="https://www.terraform.io/" target="_blank" rel="noopener">Terraform</a>中填写我们需要的设施</li>
<li>将它保存在我们源代码管理中</li>
<li>通过一个PR来获取反馈</li>
<li>测试</li>
<li>执行用来提供所有需要的资源。</li>
</ol>
<p><img src="TerraformAndAnsible.png" alt="TerraformAndAnsible"><br>同时Ansible可能后面会慢慢淘汰，因为 immutable deployments的推行。所有的环境配置都是一致的无需改变的。<br>怎么开始： Terraform+AWS 套餐可以看下。  </p>
<h2 id="版本version"><a href="#版本version" class="headerlink" title="版本version"></a>版本version</h2><p>使用git进行版本控制。<br>最少你应该精通以下：</p>
<ol>
<li>Fork一个仓库</li>
<li>创建分支</li>
<li>从upstream中合并改变，并且回来</li>
<li>创建一个Pull Requests。</li>
</ol>
<h2 id="打包-Package"><a href="#打包-Package" class="headerlink" title="打包 Package"></a>打包 Package</h2><p><a href="https://medium.com/@devfire/how-to-become-a-devops-engineer-in-six-months-or-less-part-4-package-47677ca2f058" target="_blank" rel="noopener">https://medium.com/@devfire/how-to-become-a-devops-engineer-in-six-months-or-less-part-4-package-47677ca2f058</a><br>虚拟化技术可以节省等待时间并且更快部署。  </p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker就是基于一个很久以前的想法：在同样的操作系统中对每个单独的进程进行隔离。这不是’full virtualization’:在同一物理主机上并行运行虚拟机。<br>Docker 是和微服务同步兴起的，它可以解决不同的app有环境冲突的问题。比如python，java应用需要的环境配置都是不一样的。  </p>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>运行Docker仍然是运行服务器，服务器都是易碎，脆弱的。他们都需要被管理，打补丁等等。<br>同时Docker并不是100%安全的。运行容器托管的大公司都是在虚拟机中进行的而不是在裸机上运行，这样可以获得虚拟机的安全性和容器的快速。<br>最后，没有人只是运行Docker。大部分都是将它作为一个复杂容器编排结构的一部分。<br>AWS lambda允许您在不设置或管理服务器的情况下运行代码。您只需支付您所花费的计算时间-当您的代码没有运行时，不收取任何费用。<br>这尼玛是广告吧。。。<br>但是这个环境怎么实现的？？可以看看。。serverless嘛。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.sevenpan.com/2019/02/03/基础建设和杂项比较/DevOps 笔记/" data-id="cjswzmq0n000f46rrgzwgl01p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基础建设和杂项比较/一台VPS所需要的安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/22/基础建设和杂项比较/一台VPS所需要的安装/" class="article-date">
  <time datetime="2019-01-22T08:20:00.000Z" itemprop="datePublished">2019-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/22/基础建设和杂项比较/一台VPS所需要的安装/">一台VPS所需要的操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一台VPS所需要的操作"><a href="#一台VPS所需要的操作" class="headerlink" title="一台VPS所需要的操作"></a>一台VPS所需要的操作</h2><p>又弄了一台VPS，记录下我需要的下载的工具作为一个列表。免得每次都没啥头绪。</p>
<ol>
<li>创建自己的用户</li>
<li>创建SSH</li>
<li>SSR转发</li>
<li>将自己的blog网站迁移</li>
<li>安装FTP</li>
<li>自行安装简单的防火墙</li>
<li>安装Python，Java，Docker，git, PGSQL…</li>
</ol>
<h3 id="创建自己的用户"><a href="#创建自己的用户" class="headerlink" title="创建自己的用户"></a>创建自己的用户</h3><p><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-centos-quickstart" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-centos-quickstart</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adduser -p password -Um user</span><br><span class="line">#检查用户是否创建成功</span><br><span class="line">id user</span><br><span class="line">&gt;uid=500(user) gid=500(user) groups=500(user)</span><br><span class="line"># 添加它到root和wheel组</span><br><span class="line">usermod -aG wheel user</span><br><span class="line">usermod -aG root user</span><br><span class="line"># 运行sudo操作</span><br><span class="line">more sudoers</span><br><span class="line">visudoers</span><br><span class="line">#将其中的	# 这里注释掉就好了。</span><br><span class="line">## Allows people in group wheel to run all commands</span><br><span class="line"># %wheel	ALL=(ALL)	ALL</span><br></pre></td></tr></table></figure>
<p>git 用户：</p>
<pre><code>sudo adduser git
su git
cd
mkdir .ssh &amp;&amp; chmod 700 .ssh
touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys
</code></pre><h3 id="创建SSH-以及无密码登陆"><a href="#创建SSH-以及无密码登陆" class="headerlink" title="创建SSH 以及无密码登陆"></a>创建SSH 以及无密码登陆</h3><p>搬瓦工自带了ssh，我配置下无须密码输入的登陆就好了，修改本机的.bash_profiles：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	ssh user@ip -p port mkdir -p .ssh</span><br><span class="line">	cat .ssh/id_rsa.pub | ssh  user@ip -p port &apos;cat &gt;&gt; .ssh/authorized_keys&apos;</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">结果这般操作后还是不能无密码登陆，还有一些东西需要确认。</span><br></pre></td></tr></table></figure>
<pre><code>chmod 750 ~  
chmod 700 ~/.ssh
chmod 600 ~/.ssh/authorized_keys
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以及ssh的配置文件中的：</span><br><span class="line">/etc/ssh/sshd_config  </span><br><span class="line">	</span><br><span class="line">	RSAAuthentication yes</span><br><span class="line">	PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">需要解开注释。  </span><br><span class="line"></span><br><span class="line">### 安装FTP服务器</span><br><span class="line">[https://www.unixmen.com/install-configure-ftp-server-centos-7/](https://www.unixmen.com/install-configure-ftp-server-centos-7/)  </span><br><span class="line">在centos上安装ftp</span><br><span class="line">	</span><br><span class="line">	yum install vsftpd ftp -y</span><br><span class="line">编辑修改/etc/vsftpd/vsftpd.conf文件：</span><br><span class="line">	</span><br><span class="line">	 [...]</span><br><span class="line">	## Disable anonymous login ##</span><br><span class="line">	anonymous_enable=NO</span><br><span class="line">	</span><br><span class="line">	## Uncomment ##</span><br><span class="line">	ascii_upload_enable=YES</span><br><span class="line">	ascii_download_enable=YES</span><br><span class="line">	</span><br><span class="line">	## Uncomment - Enter your Welcome message - This is optional ##</span><br><span class="line">	ftpd_banner=Welcome to UNIXMEN FTP service.</span><br><span class="line">	</span><br><span class="line">	## Add at the end of this  file ##</span><br><span class="line">	use_localtime=YES	</span><br><span class="line">运行并且开启vsftpd命令：</span><br><span class="line"></span><br><span class="line">	systemctl enable vsftpd</span><br><span class="line">	systemctl start vsftpd</span><br><span class="line">创建ftp用户：</span><br><span class="line">	</span><br><span class="line">	useradd ftpuser</span><br><span class="line">	passwd ftpuser</span><br><span class="line">连接ftp用户：</span><br><span class="line"></span><br><span class="line">	ftp ftpuser@192.168.1.101	</span><br><span class="line">	</span><br><span class="line">### firewall 建立防火墙</span><br><span class="line">[https://www.linode.com/docs/security/firewalls/introduction-to-firewalld-on-centos/](https://www.linode.com/docs/security/firewalls/introduction-to-firewalld-on-centos/)</span><br><span class="line">FirewallD 是iptables的前端控制器用来实现网络交通规则。和iptables相比有两个不同：</span><br><span class="line">	</span><br><span class="line">	1. FirewallD 使用 zones 和services 而不是chain和rules</span><br><span class="line">	2. 它动态的管理规则，运行在不破坏当前sessions和链接的情况下升级。</span><br><span class="line"></span><br><span class="line">*FirewallD是一个iptables的wrapper来更加简单的管理iptables的规则。它不是iptables的替代品。所以iptables命令仍然可以在FirewallD上使用，但是只推荐在FirewallD上运行FirewallD的命令。*</span><br><span class="line">#### 在Firewalld中基本的观点</span><br><span class="line">##### Zones 区</span><br><span class="line">firewalld后台进程管理规则组称为 zones。 Zones基本上是一个规则集合支配交通应该被允许基于你相信的网络的信任级别。网络接口被分配一个区域用来治理防火墙允许的行为。    </span><br><span class="line">对于需要移动频繁的电脑，这类灵活性提供了一个很行的方式来根据网络修改你的规则。你也许有严格的规则组织大部分的网络当在一个公共WIFI网络上，当在家庭网络时会有比较宽松的限制。对于一个服务器这些区并不是特别重要，因为服务器的网络不常改变。  </span><br><span class="line">无视你的网络环境有多动态，熟悉预设区域背后的规则也会有帮助。  </span><br><span class="line">从不信任到最信任，在firewalld中预设区如下：  </span><br><span class="line"></span><br><span class="line">1. drop: 对低级别信任。所有的连接将会被丢掉并不会回复并且只有出去的网络是允许的。</span><br><span class="line">2. block:同上，但是除了简单的丢弃连接，进来的请求将会收到icmp-host-prohibited or icmp6-adm-prohibited的拒绝信息。</span><br><span class="line">3. public公共：代表公共，不信任的网络。你也许不信任其他的电脑，但是也许会允许满足一定条件的连接。</span><br><span class="line">4. external外部的：在这个情况下你使用firewall作为你的网关。这个是用来配置NAT伪装这样你的内部网络可以保存私密同时可达。</span><br><span class="line">5. internal内部的：外部区的反面，用来作为内部网关的一部分。这里的电脑是可以信任的并且一些另外的服务是可以使用的。</span><br><span class="line">6. dmz:用于给位于DMZ的计算机(对计算器进行隔离使其不能访问你的网络其他的部分)。只有确定的请求才能被允许。 </span><br><span class="line">7. work:工作的计算器。信任这个网络中的大部分计算器。可能会允许更多的服务。</span><br><span class="line">8. home:一个家庭网络。通常它中是大部分你信任的机器并且大部分的服务将会被接受。</span><br><span class="line">9. trusted：信任这个网络中的所有的机器。最开放的可用选项，应谨慎使用。</span><br><span class="line"></span><br><span class="line">##### Rule Permanence 规则的持久性</span><br><span class="line">在firewalld中，规程可以是持久的或者是暂时的。如果一个规则是被添加或者修改的，默认的，当前运行的防火墙的行为将会改变。在下一次启动的时候，旧的规则将会被reverted。  </span><br><span class="line">大部分的firewall-cmd选项可以允许 --permanent 标志来指示应针对非临时防火墙。这个将会影响重载的规则。这意味着你可以测试规则在你活跃的防火墙实例中，并且如果有任何问题可以进行重载。随着时间你可以使用--permanent标识来构建一个完整的规则。</span><br><span class="line"></span><br><span class="line">#### 安装并且启动防火墙</span><br></pre></td></tr></table></figure>
<p>sudo yum install firewalld<br>sudo systemctl enable firewalld<br>sudo reboot<br>sudo firewall-cmd –state</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">*重启以后，防火墙就启动了，这个时候，所有都连不进去了，所以。。再重新登录控制面板来操作吧。*</span><br><span class="line">一些命令：</span><br><span class="line">	</span><br><span class="line">	firewall-cmd --get-default-zone</span><br><span class="line">	output</span><br><span class="line">	public</span><br><span class="line">	firewall-cmd --get-active-zones</span><br><span class="line">	output</span><br><span class="line">	public</span><br><span class="line">	  interfaces: eth0</span><br><span class="line">	firewall-cmd --list-all</span><br><span class="line">	output</span><br><span class="line">	public (default, active)</span><br><span class="line">	  target: default</span><br><span class="line">	  icmp-block-inversion: no</span><br><span class="line">	  interfaces: eth0 eth1</span><br><span class="line">	  sources: </span><br><span class="line">	  services: ssh dhcpv6-client</span><br><span class="line">	  ports: </span><br><span class="line">	  protocols: </span><br><span class="line">	  masquerade: no</span><br><span class="line">	  forward-ports: </span><br><span class="line">	  source-ports: </span><br><span class="line">	  icmp-blocks: </span><br><span class="line">	  rich rules: </span><br><span class="line">	firewall-cmd --get-zones</span><br><span class="line">我主要运行的命令：</span><br><span class="line"></span><br><span class="line">	firewall-cmd --zone=public --list-all</span><br><span class="line">	firewall-cmd --zone=public --permanent --add-service=http</span><br><span class="line">	firewall-cmd --zone=public --permanent --add-service=ssh</span><br><span class="line">	firewall-cmd --zone=public --permanent --add-service=https</span><br><span class="line">	firewall-cmd --zone=public --permanent --add-service=ftp  </span><br><span class="line">	firewall-cmd --zone=public --permanent --add-port=21443/tcp</span><br><span class="line">	firewall-cmd --zone=public --permanent --add-port=28517/tcp</span><br><span class="line">	output</span><br><span class="line">	public (active)</span><br><span class="line">	  target: default</span><br><span class="line">	  icmp-block-inversion: no</span><br><span class="line">	  interfaces: eth0</span><br><span class="line">	  sources:</span><br><span class="line">	  services: dhcpv6-client ssh http https ftp</span><br><span class="line">	  ports: 21443/tcp 28517/tcp</span><br><span class="line">	  protocols:</span><br><span class="line">	  masquerade: no</span><br><span class="line">	  forward-ports:</span><br><span class="line">	  source-ports:</span><br><span class="line">	  icmp-blocks:</span><br><span class="line">	  rich rules:	</span><br><span class="line">	</span><br><span class="line">其实还有很多，都在文章中，可以看看，不过暂时不需要。只要port限制就好.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 安装Python，git以及Shadowsock</span><br></pre></td></tr></table></figure>
<h1 id="install-git"><a href="#install-git" class="headerlink" title="install git"></a>install git</h1><p>yum install git</p>
<h1 id="install-python-2-7-and-pip"><a href="#install-python-2-7-and-pip" class="headerlink" title="install python 2.7 and pip"></a>install python 2.7 and pip</h1><p>sudo yum install -y python-setuptools<br>sudo easy_install pip</p>
<h1 id="install-ssr"><a href="#install-ssr" class="headerlink" title="install ssr:"></a>install ssr:</h1><p>sudo pip install git+<a href="https://github.com/shadowsocks/shadowsocks.git@master" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks.git@master</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接下来就是在服务器里面进行配置了：</span><br><span class="line"></span><br><span class="line">1. 设置配置文件：vi /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure></p>
<pre><code>{
&quot;server&quot;: &quot;0.0.0.0&quot;,
&quot;server_port&quot;: 443,
&quot;local_address&quot;: &quot;127.0.0.1&quot;,
&quot;local_port&quot;: 21080,
&quot;password&quot;: &quot;password&quot;,
&quot;timeout&quot;: 300,
&quot;method&quot;: &quot;aes-256-cfb&quot;,
&quot;fast_open&quot;: false,
&quot;workers&quot;: 1
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 设置ssr服务为开机启动服务：</span><br><span class="line">增加一个开机启动服务service：在/usr/lib/systemd/system中。</span><br></pre></td></tr></table></figure>

[Unit]
Description=Shadowsocks

[Service]
TimeoutStartSec=0
ExecStart=/usr/bin/ssserver -c /etc/shadowsocks/config.json

[Install]
WantedBy=multi-user.target
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">	运行以下的命令：  </span><br><span class="line"></span><br><span class="line">```	</span><br><span class="line">systemctl enable shadowsocks</span><br><span class="line">systemctl start shadowsocks</span><br><span class="line">systemctl status shadowsocks -l</span><br></pre></td></tr></table></figure>
</code></pre><ol start="3">
<li>远程测试一下<br> telnet ip 443</li>
</ol>
<p>有一个不错的写了安装脚本的，可以看下，学习下:<br>install-shadowsocks.sh:</p>
<pre><code>#!/bin/bash
# Install Shadowsocks on CentOS 7

echo &quot;Installing Shadowsocks...&quot;

random-string()
{
    cat /dev/urandom | tr -dc &apos;a-zA-Z0-9&apos; | fold -w ${1:-32} | head -n 1
}

CONFIG_FILE=/etc/shadowsocks.json
SERVICE_FILE=/etc/systemd/system/shadowsocks.service
SS_PASSWORD=$(random-string 32)
SS_PORT=8388
SS_METHOD=aes-256-cfb
SS_IP=`ip route get 1 | awk &apos;{print $NF;exit}&apos;`
GET_PIP_FILE=/tmp/get-pip.py

# install pip
curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;${GET_PIP_FILE}&quot;
python ${GET_PIP_FILE}

# install shadowsocks
pip install --upgrade pip
pip install shadowsocks

# create shadowsocls config
cat &lt;&lt;EOF | sudo tee ${CONFIG_FILE}
{
  &quot;server&quot;: &quot;0.0.0.0&quot;,
  &quot;server_port&quot;: ${SS_PORT},
  &quot;password&quot;: &quot;${SS_PASSWORD}&quot;,
  &quot;method&quot;: &quot;${SS_METHOD}&quot;
}
EOF

# create service
cat &lt;&lt;EOF | sudo tee ${SERVICE_FILE}
[Unit]
Description=Shadowsocks

[Service]
TimeoutStartSec=0
ExecStart=/usr/bin/ssserver -c ${CONFIG_FILE}

[Install]
WantedBy=multi-user.target
EOF

# start service
systemctl enable shadowsocks
systemctl start shadowsocks

# view service status
sleep 5
systemctl status shadowsocks -l

echo &quot;================================&quot;
echo &quot;&quot;
echo &quot;Congratulations! Shadowsocks has been installed on your system.&quot;
echo &quot;You shadowsocks connection info:&quot;
echo &quot;--------------------------------&quot;
echo &quot;server:      ${SS_IP}&quot;
echo &quot;server_port: ${SS_PORT}&quot;
echo &quot;password:    ${SS_PASSWORD}&quot;
echo &quot;method:      ${SS_METHOD}&quot;
echo &quot;--------------------------------&quot;
</code></pre><h3 id="将自己的个人博客转到这个服务器上"><a href="#将自己的个人博客转到这个服务器上" class="headerlink" title="将自己的个人博客转到这个服务器上"></a>将自己的个人博客转到这个服务器上</h3><h4 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br><span class="line">rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line">yum install nginx</span><br></pre></td></tr></table></figure>
<h4 id="将hexo配置上"><a href="#将hexo配置上" class="headerlink" title="将hexo配置上"></a>将hexo配置上</h4><h5 id="server端的修改"><a href="#server端的修改" class="headerlink" title="server端的修改"></a>server端的修改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#设置hexo到服务器上</span><br><span class="line">mkdir -p code/gitLibrary/blog/hexo</span><br><span class="line">#设置nginx配置，主要是目录：</span><br><span class="line">sudo vi /etc/nginx/nginx.conf</span><br><span class="line">#在配置中添加以下内容</span><br><span class="line">	http&#123;</span><br><span class="line">			gzip on;</span><br><span class="line">			server &#123;</span><br><span class="line">		      		listen       80 default_server;</span><br><span class="line">		      		listen       [::]:80 default_server;</span><br><span class="line">		      		server_name  blog.domain.com; # 填写个人域名</span><br><span class="line">		      		root         /home/user/code/gitLibrary/blog/hexo;</span><br><span class="line">		 	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">#修改hexo git配置</span><br><span class="line">cd /home/user/code/gitLibrary/hexo.git/hooks</span><br><span class="line">vi post-update</span><br><span class="line">#添加一下的内容到文件中。 前面是需要上传的地址路径，后面是git的目录地址</span><br><span class="line">git --work-tree=/home/user/code/gitLibrary/blog/hexo --git-dir=/home/user/code/gitLibrary/hexo.git checkout -f</span><br></pre></td></tr></table></figure>
<p>启动nginx：</p>
<pre><code>sudo nginx -t
systemctl start nginx
systemctl status nginx
</code></pre><p><strong>踩了一个坑，nginx老是无法访问对应的文件，然后我检查的时候看到相应的文件都以及设置了可读的权限，但是仍然无法访问。后面自己在建立了一个用户来测试，才发现，对于目录文件来说，权限要设置为可读且可执行的才能被读取里面的文件，也就是755的权限了。</strong>    </p>
<h5 id="本地机器的修改"><a href="#本地机器的修改" class="headerlink" title="本地机器的修改"></a>本地机器的修改</h5><p>修改deploy的git远程机器：</p>
<pre><code>vi /Users/user/code/blog/_config.yml
#deploy中需要改为如下：
deploy:
  type: git
  repo: ssh://user@ip:port/home/user/code/gitLibrary/hexo
  brach: master
</code></pre><h5 id="域名转换"><a href="#域名转换" class="headerlink" title="域名转换"></a>域名转换</h5><p>IP变了，所以要去域名服务商改下ip。<br>比如我这个是在name    上，进入<a href="https://www.name.com/zh-cn/account/domain/details/sevenpan.com#dns" target="_blank" rel="noopener">DNS</a>设置自己的ip就可以进行转发了。      </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.sevenpan.com/2019/01/22/基础建设和杂项比较/一台VPS所需要的安装/" data-id="cjswzmq0r000i46rrtuk05yds" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo-git-nginx-ssh/">hexo,git,nginx,ssh,</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基础建设和杂项比较/RPC,REST,SOAP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/23/基础建设和杂项比较/RPC,REST,SOAP/" class="article-date">
  <time datetime="2018-11-23T05:58:11.000Z" itemprop="datePublished">2018-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RPC，-REST-SOAP"><a href="#RPC，-REST-SOAP" class="headerlink" title="RPC， REST, SOAP"></a>RPC， REST, SOAP</h2><p><a href="https://blog.apisyouwonthate.com/understanding-rpc-rest-and-graphql-2f959aadebe7" target="_blank" rel="noopener">https://blog.apisyouwonthate.com/understanding-rpc-rest-and-graphql-2f959aadebe7</a>  </p>
<h3 id="RPC-Remote-Procedure-Call-RPC"><a href="#RPC-Remote-Procedure-Call-RPC" class="headerlink" title="RPC Remote Procedure Call (RPC)"></a>RPC Remote Procedure Call (RPC)</h3><p>RPC 是最简单最早的一种API交互。它可以执行其他服务器上的代码，并且当用http或者AMQP实现的时候，它就是一个web API.  RPC只是很多的函数但是是在HTTP API 的上下文中， 导致需要将方法放到URL中并且参数放到查询的字符串或者请求中。<br>当被用来执行CRUD操作的时候，RPC只是用来发送和下载数据字段，但是有一个很不好的地方是客户端需要负责很多东西。客户端为了构造它自己的工作流，需要知道哪个方法在什么时候调用。<br>RPC只是一个概念，但是这个概念有很多的要求，这些要求都有对应的实现:</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/XML-RPC" target="_blank" rel="noopener">XML-RPC</a></li>
<li><a href="https://en.wikipedia.org/wiki/JSON-RPC" target="_blank" rel="noopener">JSON-RPC</a></li>
<li><a href="https://en.wikipedia.org/wiki/SOAP" target="_blank" rel="noopener">Simple Object Access Protocol(SOAP)</a></li>
</ol>
<p>XML-RPC 和JSON-RPC被使用的并不多，而SOAP被使用在大部分的金融和企业系统中，比如Salesforce，其实我之前的公司也是使用的SOAP。<br>XML-RPC在使用的时候由于XML的数据类型无法完全满足，所以会有一些问题。在XML中，很多东西只是字符串而已， JSON对此有一些改进，但是对于区分不同的数据格式比如整形和小数还是有问题。(<b>似乎这里可以看下，是否xml和json有这两个问题</b>)<br>你需要将元数据放到最顶层用于描述字段对应的数据类型。这就是SOAP的一部分基础，使用<a href="https://en.wikipedia.org/wiki/XML_schema" target="_blank" rel="noopener">XML Schema</a>和一个<a href="https://en.wikipedia.org/wiki/Web_Services_Description_Language" target="_blank" rel="noopener">Web Services Description Language(WSDL)</a> 来解释去到哪和包含了什么。<br>插播下什么是XML Schema 和WSDL吧，毕竟以前接触的还比较多，但是一直不太明白它们。  </p>
<pre><code>XML schema 是一个用于描述XML文件类型的东西。通常表示结构的约束和这个文档的内容的类型，是在XML基础之上的一种约束。这些约束通常被表述为语法条件的组合来治理元素的顺序，内容需要满足布尔预测， 数据类型治理元素的内容和状态，以及更多的特殊规则比如唯一性和参照完整性约束。 咳咳，通俗易懂的说，这个文件用于指定一些约束，比如，这个字段是否可以为可选的，还是必须的，如果一个字段有是否也需要另外的字段的存在。也就是可以将一些业务约束或者说是接口约束写入这个文件中，让其进行检查，而不需要在业务代码中进行检查。比较精致的做法是这样，但是在之前的工作中，一般会弃用这个约束，因为该文件的修改设计到外系统的同步，修改比较麻烦，不如完全放松，接口先通，自己进行内部调整。  
WSDL（网络服务描述语言 Web Services Description Language）是一个基于XML的接口定义语言用来描述一个web服务提供的功能。这个缩写也用来表示一个web服务的WSDL描述，提供一个机器可读的描述来告知这个服务可以被调用，它期望的参数是什么，它将返回什么数据结构。所以，WSDL的目的和一个编程语言的类型签名有一些相似。WSDL将服务描述为网络endpoints或者端口的集合。WSDL说明书提供一个XML格式的文档来达到这个目的。抽象定义的端口和信息被从它们的具体使用或者实例中抽离出来，从而允许定义的复用。端口是通过关联一个网络地址的可重复绑定来定义，端口的集合定义了一个服务。这个对于一个端口具体的协议和数据格式规格组成了一个可复用的绑定，而操作和信息会绑定到具体的网络协议和消息格式。通过这样，WSDL描述了这个Web service的公共接口。上面这段描述有些抽象，后续我考虑补充点例子进来。  
</code></pre><p>这些元数据就像是单位。比如是分还是元，很重要咯。<br>一个现代的RPC实现是<a href="https://grpc.io/" target="_blank" rel="noopener">gRPC</a>，可以被简单的考虑为更好的SOAP。它使用了一个数据类型称为<a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">ProtoBuff</a>,既需要模式也需要数据实例，非常像是SOAP中的WSDL。<br>GRPC专注于使单次交互尽可能的快，它利用了HTTP/2和Protobuff包要小于JSON的特点。但是JSon也可以很容易的使用。  </p>
<h3 id="Representation-State-Transfer-REST"><a href="#Representation-State-Transfer-REST" class="headerlink" title="Representation State Transfer (REST)"></a>Representation State Transfer (REST)</h3><p>REST 是一个网络范式在2000年被Roy Fielding 提出。REST 是关于客户端和服务器端关系的，服务端的数据通过表达数据为简单的格式来达到可用性。这个格式可以是JSON或者XML或者任何东西。<br>这些表达从不同的来源中描述数据，简单称为资源或者资源的集合，它们都是可以通过称为超媒体控件(HATEOAS)的概念使action和关系变得可发现而潜在地可修改。<br>Hypermedia 是REST的基础，本质上是提供接下来可用的操作，这些操作可以是和数据有关，或者一个”Invoice”资源的例子，它可能被链接到一个支付尝试集合，这样这个用户可以尝试支付订单。<br>这些动作只是链接，但是这里的重点是这个客户知道这里有一个订单是可以支付的通过展示一个”支付”链接，并且如果这个链接不存在，那么这个选项也不应该展示给终端用户。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;invoice&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;093b941d&quot;,</span><br><span class="line">    &quot;attributes&quot;: &#123;</span><br><span class="line">      &quot;created_at&quot;: &quot;2017–06–15 12:31:01Z&quot;,</span><br><span class="line">      &quot;sent_at&quot;: &quot;2017–06–15 12:34:29Z&quot;,</span><br><span class="line">      &quot;paid_at&quot;: &quot;2017–06–16 09:05:00Z&quot;,</span><br><span class="line">      &quot;status&quot;: &quot;published&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;links&quot;: &#123;</span><br><span class="line">    &quot;pay&quot;: &quot;https://api.acme.com/invoices/093b941d/payment_attempts&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就和RPC不太一样了。下面两个列子可以说明：</p>
<pre><code>客户：我可以和Dr.A说话么，他在么？
RPC：不行
客户： 我检查了他的日程，看起来今天他不在。我想和其他的医生聊聊，看起来Dr.B下午三点有空，我可以那时见到她么？
RPC：可以。
</code></pre><p>可以看到，客户承担大部分需要做的事情，它需要知道所有的数据，然后自己决定，然后才能弄清楚下一步应该做什么。而REST告诉你下一步应该做什么：</p>
<pre><code>客户：我可以和Dr.A说话么，他在么？
REST: Dr.A 现在不在，他明天会回来，但是你有以下的选项。如果你不急，可以留下信息我明天告诉他或者我可以给你预定今天其他的医生，你想要知道今天谁有空么？  
客户：是的，请告诉我今天有谁。
REST:医生B和C，这是他们的介绍。
客户:医生B看起来像是我需要的，请帮我做预约。
REST：预约已经成功，这是详细的预约内容。
</code></pre><p>REST提供了所有相关的信息在回应中，然后这个客户可以选择想要的选项。<br>在服务器中集中状态对于系统为不同的客户提供相同的工作流程很有用。不同于分布式处理全部逻辑，检查数据字段，展示Action的列表等等，对于不同的用户展示不同的结果，REST将他们都统一了。<br>对于更多超媒体控制，可以查看：<a href="https://blog.apisyouwonthate.com/representing-state-in-rest-and-graphql-9194b291d127" target="_blank" rel="noopener">Representing State in REST and GraphQL</a>和 <a href="http://apibusters.com/003-why-hypermedia" target="_blank" rel="noopener">API busters podcast- Episode 3:Why Hypermedia</a>.<br>除了超媒体(最有用但是也是最容易忽视的特点)对于一个系统拥有REST API还有其他的要求：</p>
<ol>
<li>REST必须是无状态的：请求之间没有持续的session。</li>
<li>回应应该是可缓存的：这样可以帮助你的API进行扩展，如果客户遵守这些规则。</li>
<li>REST 关注一致性：如果使用HTTP，应该尽可能使用HTTP特性，而不是创造约定。</li>
</ol>
<p>这些约束的目标是使REST架构可以帮助API持续使用。<br>REST同样也不需要使用模式元数据，那些API开发员最讨厌SOAP的东西。很长一段时间没人构建REST APIs通过schema，但是现在这个变的比较普遍由于<a href="http://json-schema.org/" target="_blank" rel="noopener">JSON Schema</a>。<br>JSON Schema是从XML Schema激发出来的，不是完全的功能一致，但是是HTTP API这些年中最重要的事情之一。<br>很不幸的是，REST变成了一个营销词语在2006-2014之间。它变成了程序员渴望的一种质量衡量方式，而不是去理解，然后就到处使用REST，所以很多系统说他们是REST但是只是RPC加上HTTP词语以及漂亮的URLs。你可能并不能获取任何缓存的东西，也许它只是一堆奇怪的对话，并且你并不能发现任何可以进行下一步的链接。<br>在另外一个方面，一个REST API可以被用为RPC风格的，如果客户端的开发忽略这些链接的话。这是不可取的，但是这是可能的。<br>很多人对于REST的困惑在于他们无法理解“所有额外的烦恼”，比如超媒体控制和HTTP缓存。他们没有看到这点，并且很多觉得RPC是全能的。对于他们来说，最重要的是尽可能快的执行远程代码，但是REST(同样是是高性能的)专注于longevity 和减少客户的耦合。<br>REST理论上可以使用任何的传输协议来提供满足约束的功能，但是没有传输协议可以像HTTP一样有功能性。为了使AMQP符合RET，你需要定义超媒体来控制(可能是下一个你可能调用的信息列表)，一个标准的用来声明AMQP信息的缓存性等， 并且创造很多并不存在的工具。<br>REST没有固定的规格所以导致有这些困惑，并且它也没有具体的实现。目前这有两个很受欢迎的规格提供给REST APIs来使用：  </p>
<ol>
<li><a href="http://www.odata.org/" target="_blank" rel="noopener">OData</a></li>
<li><a href="http://jsonapi.org/" target="_blank" rel="noopener">JSON-API</a></li>
</ol>
<p>如果有API宣传它自己使用了这两，它有可能是一个不错的api。你可以使用这两个作为你的客户端或者你使用一个普通的http客户端，并且自己添加一些润滑油。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.sevenpan.com/2018/11/23/基础建设和杂项比较/RPC,REST,SOAP/" data-id="cjswzmq0o000g46rrftqbfkts" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Algo/配对交易策略RQ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/07/Algo/配对交易策略RQ/" class="article-date">
  <time datetime="2018-11-07T08:21:17.000Z" itemprop="datePublished">2018-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#配对交易策略 - 初1<br>又名搬砖策略<br><a href="https://uqer.io/v3/community/share/57b6a1b4228e5b79a375925c" target="_blank" rel="noopener">https://uqer.io/v3/community/share/57b6a1b4228e5b79a375925c</a><br>几个基本的问题：</p>
<pre><code>1. 如何找到股票相关性高的股票？
2. 怎么确定股票比较之间的长期稳定关系
3. 怎么依据长期稳定关系来建立策略
</code></pre><h2 id="另外一个pariTrading的介绍"><a href="#另外一个pariTrading的介绍" class="headerlink" title="另外一个pariTrading的介绍"></a>另外一个pariTrading的介绍</h2><p><a href="https://medium.com/auquan/pairs-trading-data-science-7dbedafcfe5a" target="_blank" rel="noopener">https://medium.com/auquan/pairs-trading-data-science-7dbedafcfe5a</a><br>多重比较偏差：会有增加的错误生成一个明显的p-value的可能性当有太多的测试在运行的时候。 如果100个测试运行在随机数据上，我们应该期望看到5个p-value低于0.05.如果你比较n个证券，你将会执行n((n-1)/2次比较，你将会希望看到很多不正确的p-valus,他们将会随着你增加比较次数而增加。为了避免这个问题，你应该选择小数量的对来测试可能协整并且测试单独测试每一个。<br><b>？？？ 为啥测的多了可能会产生过多的错误的结果？还是不太懂。然后比较小的数量，这个数量应该怎么确定了？</b><br>接下来文章中介绍的是使用标普500的股票数据来产生交易对。文章提到：<br><b>This method is prone to multiple comparison bias and in practice the securities should be subject to a second verification step.</b><br>这里面的二次验证是指？  </p>
<p>Z Score(Value) = (Value - Mean)/Standard Deviation<br>在实际操作中，常常试图对数据做一定的扩展，但是这是在假设了一个底部的分布时候。 通常是正太分布。然而，很多金融数据并不是正太分布的，我们必须很小心，而不是简单的假设为正太分布或者特定的分布，当生成统计时。真正的比率分布可能会十分的肥尾，倾向于极端的价值弄乱了我们的模型，并且产生很大的损失。  </p>
<p><b>fat-tailed distribution</b><br>    <a href="https://en.wikipedia.org/wiki/Fat-tailed_distribution" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Fat-tailed_distribution</a></p>
<pre><code>A fat-tailed distribution is a probability distribution that exhibits a large skewness or kurtosis, relative to that of either a normal distribution or an exponential distribution.  
长尾分布是一个概率分布展示了很大的偏差或者峰度相对于一个正太分布或者一个预期内的分布而说。  
</code></pre><p>产生一个交易信号有以下的几个步骤：  </p>
<ol>
<li>收集可靠的数据，清理数据</li>
<li>从数据中创造特征来识别一个交易信号或者逻辑</li>
<li>特征可以是Moving Average 或者价格数据的比例，相关性或者更多复杂的信号 — 将它们联合起来创造更多的特征。  </li>
<li>通过这些特征来生成信号，比如交易品应该买，买或者中性。  </li>
</ol>
<p>在这篇文章中，产生一个配对交易策略的步骤可以如下：</p>
<ol>
<li>我们试图创造一个信号来告诉我们是否这个比例应买或者卖 在下一个时间里。比如这个ratio是Y<br> Y(t) = Sign(Ratio(t+1) - Ratio(t))</li>
<li>获取数据，此处广告省略了。</li>
<li>分割数据，70%用于训练，30%用于测试。</li>
<li>特征构建<br> 相关特征应该是哪些？我们想要预测ratio的移动方向。我们已经看到两个证券是协整的，所以这个ratio将会在mean值之间上下运动。当前值和mean的差将会用于生成交易信号。<br> 我们使用以下的特征：  <ol>
<li>60天移动平均线：滚动平均值的测量</li>
<li>5天移动平均线： 测量的当前均值</li>
<li>60天的标准偏差</li>
<li>z score： (5d MA — 60d MA) /60d SD</li>
</ol>
</li>
<li><p>模型的选择<br> 研究z-score的图表可以看出来，无论这个值太大或者太小它都将会回复到均值的水平。我们使用+1/-1作为阀值来代表过高或者太低，然后我们可以采用以下模型来生成一个交易信号：<br> Ratio 是buy(1)当z-score低于-1.0时，因为我们期望z score将会回到0，也就是增加.<br> Ratio 是sell(-1)当z-score高于1.0时，因为我们期望z score将会回到0，也就是降低.</p>
</li>
<li><p>训练，校验和优化  </p>
<h3 id="避免过度拟合"><a href="#避免过度拟合" class="headerlink" title="避免过度拟合"></a>避免过度拟合</h3><p>在上述模型中，使用了rolling参数来创建而且也许希望来优化窗口大小。我们也许可以使用一个简单的迭代来计算全部的可能的窗口大小，然后使用最好的表现的窗口大小。但是就是会有过度拟合的问题。为了解决这个问题，这个文章里提到的是使用经济学的解释或者使用算法的特性来选择窗口长度。当然还有一个方法： Kalman filter，这个据说不需要制定一个特定的长度，我准备接下来看下这个。  </p>
</li>
</ol>
<h3 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h3><p>上述只是一个简单的开发pairtrading策略的过程，在现实中，我们应该使用更复杂的统计学方式，比如：</p>
<pre><code>1. Hurst Exponent
2. Half-life of mean reversion inferred from an Ornstein-Uhlenbeck process
3. Kalman filters
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.sevenpan.com/2018/11/07/Algo/配对交易策略RQ/" data-id="cjswzmq0a000546rrsznjoubm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Algo/Somethings About Pyalgotrade" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/17/Algo/Somethings About Pyalgotrade/" class="article-date">
  <time datetime="2018-10-17T05:27:39.000Z" itemprop="datePublished">2018-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/17/Algo/Somethings About Pyalgotrade/">Somethings About Pyalgotrade  - the Optimizing</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://gbeced.github.io/pyalgotrade/docs/v0.20/html/tutorial.html#optimizing" target="_blank" rel="noopener">http://gbeced.github.io/pyalgotrade/docs/v0.20/html/tutorial.html#optimizing</a></p>
<h2 id="The-optimizing"><a href="#The-optimizing" class="headerlink" title="The optimizing"></a>The optimizing</h2><p>优化，💡很简单：</p>
<pre><code>一台server用于：
    1. 提供bars用来运行策略
    2. 提供参数用来运行策略
    3. 记录每一个worker的运行策略的结果
很多worker用来：
    使用server提供的参数和数据来运行策略
</code></pre><p>为了展示这个，我们将会使用一个称为RSI2的策略，该策略需要以下的参数：</p>
<pre><code>一个SMA时间段用于区分趋势。我们将会将这个参数称为entrySMA，并且范围选取在150和250之间。  
一个小一些的SMA时间段用于退出参数。我们称之为exitSMA，范围在5到15之间。  
一个RSI时间段用于进入买或者卖，我们称之为rsiPeriod，范围在2到10之间。  
一个RSI超卖阀值用于进入买入点位，我们称之为overSoldThreshold，并且范围在5和25之间。  
一个RSI超买阀值用于进入卖出点位，我们称之为overBoughtThreshold，范围将在75和95之间。
</code></pre><p><b>所以这里一共有：101 <em> 11 </em> 9 <em> 21 </em> 21 = 4409559</b><br>如果一个策略需要运行0.16秒，那么一共需要8.5天才能算出所有的策略。(4409559 <em> 0.16/3600/24 ～ 8.16 Days)<br>如果是利用上了10台八核的机器，时间将会缩短到2.5个小时。（4409559 </em> 0.16/3600/24/8/10 * 24(h) ~ 2.44 h) 所以我们需要并发。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">from pyalgotrade import strategy</span><br><span class="line">from pyalgotrade.technical import ma</span><br><span class="line">from pyalgotrade.technical import rsi</span><br><span class="line">from pyalgotrade.technical import cross</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RSI2(strategy.BacktestingStrategy):</span><br><span class="line">    def __init__(self, feed, instrument, entrySMA, exitSMA, rsiPeriod, overBoughtThreshold, overSoldThreshold):</span><br><span class="line">        super(RSI2, self).__init__(feed)</span><br><span class="line">        self.__instrument = instrument</span><br><span class="line">        # We&apos;ll use adjusted close values, if available, instead of regular close values.</span><br><span class="line">        if feed.barsHaveAdjClose():</span><br><span class="line">            self.setUseAdjustedValues(True)</span><br><span class="line">        self.__priceDS = feed[instrument].getPriceDataSeries()</span><br><span class="line">        self.__entrySMA = ma.SMA(self.__priceDS, entrySMA)</span><br><span class="line">        self.__exitSMA = ma.SMA(self.__priceDS, exitSMA)</span><br><span class="line">        self.__rsi = rsi.RSI(self.__priceDS, rsiPeriod)</span><br><span class="line">        self.__overBoughtThreshold = overBoughtThreshold</span><br><span class="line">        self.__overSoldThreshold = overSoldThreshold</span><br><span class="line">        self.__longPos = None</span><br><span class="line">        self.__shortPos = None</span><br><span class="line"></span><br><span class="line">    def getEntrySMA(self):</span><br><span class="line">        return self.__entrySMA</span><br><span class="line"></span><br><span class="line">    def getExitSMA(self):</span><br><span class="line">        return self.__exitSMA</span><br><span class="line"></span><br><span class="line">    def getRSI(self):</span><br><span class="line">        return self.__rsi</span><br><span class="line"></span><br><span class="line">    def onEnterCanceled(self, position):</span><br><span class="line">        if self.__longPos == position:</span><br><span class="line">            self.__longPos = None</span><br><span class="line">        elif self.__shortPos == position:</span><br><span class="line">            self.__shortPos = None</span><br><span class="line">        else:</span><br><span class="line">            assert(False)</span><br><span class="line"></span><br><span class="line">    def onExitOk(self, position):</span><br><span class="line">        if self.__longPos == position:</span><br><span class="line">            self.__longPos = None</span><br><span class="line">        elif self.__shortPos == position:</span><br><span class="line">            self.__shortPos = None</span><br><span class="line">        else:</span><br><span class="line">            assert(False)</span><br><span class="line"></span><br><span class="line">    def onExitCanceled(self, position):</span><br><span class="line">        # If the exit was canceled, re-submit it.</span><br><span class="line">        position.exitMarket()</span><br><span class="line"></span><br><span class="line">    def onBars(self, bars):</span><br><span class="line">        # Wait for enough bars to be available to calculate SMA and RSI.</span><br><span class="line">        if self.__exitSMA[-1] is None or self.__entrySMA[-1] is None or self.__rsi[-1] is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        bar = bars[self.__instrument]</span><br><span class="line">        if self.__longPos is not None:</span><br><span class="line">            if self.exitLongSignal():</span><br><span class="line">                self.__longPos.exitMarket()</span><br><span class="line">        elif self.__shortPos is not None:</span><br><span class="line">            if self.exitShortSignal():</span><br><span class="line">                self.__shortPos.exitMarket()</span><br><span class="line">        else:</span><br><span class="line">            if self.enterLongSignal(bar):</span><br><span class="line">                shares = int(self.getBroker().getCash() * 0.9 / bars[self.__instrument].getPrice())</span><br><span class="line">                self.__longPos = self.enterLong(self.__instrument, shares, True)</span><br><span class="line">            elif self.enterShortSignal(bar):</span><br><span class="line">                shares = int(self.getBroker().getCash() * 0.9 / bars[self.__instrument].getPrice())</span><br><span class="line">                self.__shortPos = self.enterShort(self.__instrument, shares, True)</span><br><span class="line"></span><br><span class="line">    def enterLongSignal(self, bar):</span><br><span class="line">        return bar.getPrice() &gt; self.__entrySMA[-1] and self.__rsi[-1] &lt;= self.__overSoldThreshold</span><br><span class="line"></span><br><span class="line">    def exitLongSignal(self):</span><br><span class="line">        return cross.cross_above(self.__priceDS, self.__exitSMA) and not self.__longPos.exitActive()</span><br><span class="line"></span><br><span class="line">    def enterShortSignal(self, bar):</span><br><span class="line">        return bar.getPrice() &lt; self.__entrySMA[-1] and self.__rsi[-1] &gt;= self.__overBoughtThreshold</span><br><span class="line"></span><br><span class="line">    def exitShortSignal(self):</span><br><span class="line">        return cross.cross_below(self.__priceDS, self.__exitSMA) and not self.__shortPos.exitActive()</span><br></pre></td></tr></table></figure>
<p>有以下的函数被定义：</p>
<pre><code>#获取进入SMA的值，range从150到250
getEntrySMA(self)
#获取退出SMA的值，range从5到16
getExitSMA(self)
#获取rsi 时段的值，range从2到10
getRSI(self)
#取消建仓逻辑 --- 这里不太明白为什么要增加
onEnterCanceled(self, position)
#平仓逻辑 --- 这里不太明白为什么要增加    
onExitOk(self, position)
#平仓取消逻辑 --- 这里不太明白为什么要增加    
onExitCanceled(self, position)
#策略执行逻辑
onBars(self, bars)
#做多信号
enterLongSignal(self, bar)
#退出做多信号
exitLongSignal(self)
#做空信号
enterShortSignal(self, bar)
#退出做空信号
exitShortSignal(self)
</code></pre><p>其中，onBars(self, bars)函数用于执行策略逻辑，在onBars中，如果目前有仓位，调用了exitLongSignal() 和 exitShortSignal 用于判断是非要执行平仓操作。如果目前空仓，则调用了enterLongSignal()和enterShortSignal()来决定是否建仓。其中，getBroker().getCash()可以获取当前的现金，0.9应该是估算了交易费用。而其中的enterShort()和enterLong()函数应该是BacktestingStrategy类所含有的函数。  </p>
<p>从上面一段函数基本逻辑可以分析出，Pyalgotrade 有两个基本的类，我需要关注：</p>
<pre><code>from pyalgotrade import strategy
strategy.BacktestingStrategy
position
pyalgotrade.technical
</code></pre><p>然后还有旁枝但是不用太过关心的类：</p>
<pre><code>feed
from pyalgotrade.barfeed import quandlfeed
feed = quandlfeed.Feed()
</code></pre><p>回到优化这个主题上来，server的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line">from pyalgotrade.optimizer import server</span><br><span class="line">from pyalgotrade.barfeed import quandlfeed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def parameters_generator():</span><br><span class="line">    instrument = [&quot;ibm&quot;]</span><br><span class="line">    entrySMA = range(150, 251)</span><br><span class="line">    exitSMA = range(5, 16)</span><br><span class="line">    rsiPeriod = range(2, 11)</span><br><span class="line">    overBoughtThreshold = range(75, 96)</span><br><span class="line">    overSoldThreshold = range(5, 26)</span><br><span class="line">    return itertools.product(instrument, entrySMA, exitSMA, rsiPeriod, overBoughtThreshold, overSoldThreshold)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The if __name__ == &apos;__main__&apos; part is necessary if running on Windows.</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # Load the bar feed from the CSV files.</span><br><span class="line">    feed = quandlfeed.Feed()</span><br><span class="line">    feed.addBarsFromCSV(&quot;ibm&quot;, &quot;WIKI-IBM-2009-quandl.csv&quot;)</span><br><span class="line">    feed.addBarsFromCSV(&quot;ibm&quot;, &quot;WIKI-IBM-2010-quandl.csv&quot;)</span><br><span class="line">    feed.addBarsFromCSV(&quot;ibm&quot;, &quot;WIKI-IBM-2011-quandl.csv&quot;)</span><br><span class="line"></span><br><span class="line">    # Run the server.</span><br><span class="line">    server.serve(feed, parameters_generator(), &quot;localhost&quot;, 5000)</span><br></pre></td></tr></table></figure>
<p>这个代码处理了三个事情：</p>
<ol>
<li>声明了一个生成器函数根据范围产生不同的参数。</li>
<li>加载csv文件到feed中。</li>
<li>运行server监听5000端口来获取到来的链接。</li>
</ol>
<p>worker 脚本使用了 <code>pyalgotrade.optimizer.worker</code> 模块来并行运行策略，并且使用了server提供的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pyalgotrade.optimizer import worker</span><br><span class="line">import rsi2</span><br><span class="line"></span><br><span class="line"># The if __name__ == &apos;__main__&apos; part is necessary if running on Windows.</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    worker.run(rsi2.RSI2, &quot;localhost&quot;, 5000, workerName=&quot;localworker&quot;)</span><br></pre></td></tr></table></figure>
<p><b>注意你应该在一台server和大于等于一个worker的情况下运行</b><br>如果你只是想要在你的台式机上并发运行策略，那么可以利用<code>pyalgotrade.optimizer.local</code>模块来处理如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line">from pyalgotrade.optimizer import local</span><br><span class="line">from pyalgotrade.barfeed import quandlfeed</span><br><span class="line">import rsi2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def parameters_generator():</span><br><span class="line">    instrument = [&quot;ibm&quot;]</span><br><span class="line">    entrySMA = range(150, 251)</span><br><span class="line">    exitSMA = range(5, 16)</span><br><span class="line">    rsiPeriod = range(2, 11)</span><br><span class="line">    overBoughtThreshold = range(75, 96)</span><br><span class="line">    overSoldThreshold = range(5, 26)</span><br><span class="line">    return itertools.product(instrument, entrySMA, exitSMA, rsiPeriod, overBoughtThreshold, overSoldThreshold)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The if __name__ == &apos;__main__&apos; part is necessary if running on Windows.</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # Load the bar feed from the CSV files.</span><br><span class="line">    feed = quandlfeed.Feed()</span><br><span class="line">    feed.addBarsFromCSV(&quot;ibm&quot;, &quot;WIKI-IBM-2009-quandl.csv&quot;)</span><br><span class="line">    feed.addBarsFromCSV(&quot;ibm&quot;, &quot;WIKI-IBM-2010-quandl.csv&quot;)</span><br><span class="line">    feed.addBarsFromCSV(&quot;ibm&quot;, &quot;WIKI-IBM-2011-quandl.csv&quot;)</span><br><span class="line"></span><br><span class="line">    local.run(rsi2.RSI2, feed, parameters_generator())</span><br></pre></td></tr></table></figure>
<p>这段代码做了3件事情：</p>
<ol>
<li>声明了一个生成函数用来产出不同的参数组合</li>
<li>从csv中加载到feed中</li>
<li>使用<code>pyalgotrade.optimizer.local</code>来并发运行策略，并且找到最好的组合。  </li>
</ol>
<p>上面一段并发的演示说明如果我想要并发运行，也许我需要看看：  </p>
<pre><code>#单机本地并发代码
from pyalgotrade.optimizer import local
local.run(rsi2.RSI2, feed, parameters_generator())
#多台机器并发的代码
from pyalgotrade.optimizer import worker
worker.run(rsi2.RSI2, &quot;localhost&quot;, 5000, workerName=&quot;localworker&quot;)
</code></pre><p><b>以及说明pyalgotrade的优化部分应该是利用了并发来加速。</b><br>对于我自己的处理，可以考虑加入PSO 优化用于处理。</p>
<p>##</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.sevenpan.com/2018/10/17/Algo/Somethings About Pyalgotrade/" data-id="cjswzmpzz000046rrp4ljz4o3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algotrading-pyalgotrade/">Algotrading, pyalgotrade</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基础建设和杂项比较/hexoWithGit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/13/基础建设和杂项比较/hexoWithGit/" class="article-date">
  <time datetime="2018-10-13T14:18:38.000Z" itemprop="datePublished">2018-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/13/基础建设和杂项比较/hexoWithGit/">Hexo With Git</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>环境：  </p>
<pre><code>ubuntu 16.01LTS
</code></pre><p><b>nginx:</b><br>安装 nginx：</p>
<pre><code>sudo apt-get update
sudo apt-get install nginx
</code></pre><p>配置：  </p>
<pre><code>/etc/nginx/nginx.conf
....
server {
          listen       80 default_server;
          listen       [::]:80 default_server;
          server_name  blog.example.com; # 填写个人域名
          root         /home/where/your/blog/hexo;
  }    
  .....
</code></pre><p>/etc/nginx/sites-enabled 中有一个default文件，如果不需要可以删除，否则启动nginx的时候会报端口冲突。<br>启动nginx：</p>
<pre><code>sudo nginx -t
sudo systemctl reload nginx.service
</code></pre><p><b>git:</b><br>    本部分一大段来自：<a href="https://www.jianshu.com/p/e03e363713f9" target="_blank" rel="noopener">https://www.jianshu.com/p/e03e363713f9</a><br>    安装 git：</p>
<pre><code>sudo apt-get install git-core
mkdir -p /home/git/blog/hexo.git #Git仓库，不存储网站文件
mkdir /home/git/blog/hexo #实际存储网站文件目录
</code></pre><p>初始化空的Git仓库：</p>
<pre><code>git init --bare /home/git/blog/hexo.git
</code></pre><p>进入该仓库，配置post-update hooks（有的可能是post-receive）：</p>
<pre><code>cd /home/git/blog/hexo.git/hooks
sudo nano /home/git/blog/hexo.git/hooks/post-update.sample        
git --work-tree=/home/git/blog/hexo --git-dir=/home/git/blog/hexo.git checkout -f
chmod +x post-update
</code></pre><h2 id="local"><a href="#local" class="headerlink" title="local"></a>local</h2><p>本机设置<br>安装hexo相关：</p>
<pre><code>npm install hexo-cli hexo-server hexo-deployer-git -g
</code></pre><p>安装完成后，初始化：</p>
<pre><code>hexo init ~/myBlog
</code></pre><p>修改hexo的配置可以参考：<a href="https://hexo.io/docs/configuration" target="_blank" rel="noopener">https://hexo.io/docs/configuration</a><br>其中 deploy部分需要修改如下：</p>
<pre><code>deploy:     //发布对应的github账号
type: git
repo: user@remoteServer:/home/git/blog/hexo  //用户名@域名或 IP 地址:/home/git/blog/hexo
branch: master
</code></pre><p>然后还有一点，需要ssh-copy-key 将自己的公钥拷贝到远程机器上，这样可以无需密码访问，具体请自行搜索下。</p>
<p>完成以上之后，部署三条命令：</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre><h2 id="域名转换"><a href="#域名转换" class="headerlink" title="域名转换"></a>域名转换</h2><p>如果有自己的域名，可以在自己的域名服务商上进行设置，这样就可以直接访问域名了。<br>比如我这个是在name    上，进入<a href="https://www.name.com/zh-cn/account/domain/details/sevenpan.com#dns" target="_blank" rel="noopener">DNS</a>设置自己的ip就可以进行转发了。</p>
<h2 id="Reference-Link"><a href="#Reference-Link" class="headerlink" title="Reference Link"></a>Reference Link</h2><p>Hexo: <a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a><br>nginx install :    <a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-16-04" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-16-04</a><br><a href="https://websiteforstudents.com/migrate-nginx-root-directory-on-ubuntu-17-04-17-10/" target="_blank" rel="noopener">https://websiteforstudents.com/migrate-nginx-root-directory-on-ubuntu-17-04-17-10/</a><br>name.com 域名解析：<a href="http://www.webgou.info/content/netusage/453/" target="_blank" rel="noopener">http://www.webgou.info/content/netusage/453/</a><br>主要参考的两个网页：<br><a href="https://segmentfault.com/a/1190000010680022" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010680022</a><br><a href="https://www.jianshu.com/p/e03e363713f9" target="_blank" rel="noopener">https://www.jianshu.com/p/e03e363713f9</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.sevenpan.com/2018/10/13/基础建设和杂项比较/hexoWithGit/" data-id="cjswzmq0p000h46rr5u0ne5ay" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo-git-nginx/">hexo,git,nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algo/单因子说明以及计算结果" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/21/Algo/单因子说明以及计算结果/" class="article-date">
  <time datetime="2018-09-21T13:02:03.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="单因子说明以及计算结果"><a href="#单因子说明以及计算结果" class="headerlink" title="单因子说明以及计算结果"></a>单因子说明以及计算结果</h1><p><em>本笔记是参考了报告：新兴市场第二季度因子收益报告 以及 <a href="https://cloud.tencent.com/developer/article/1174165" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1174165</a> 所写</em><br><em>增加RiceQuant获取基本面数据的方法</em><br><a href="https://www.ricequant.com/doc/rqdata-institutional#research-API-get_fundamentals" target="_blank" rel="noopener">https://www.ricequant.com/doc/rqdata-institutional#research-API-get_fundamentals</a><br><a href="https://www.ricequant.com/fundamentals" target="_blank" rel="noopener">https://www.ricequant.com/fundamentals</a></p>
<pre><code>初始化使用 riceQuant的方式如下：
1.进入之前系统预装的rq python虚拟机中
2.运行如下的命令：
    import rqdatac as rq
    from rqdatac import *
    rq.init()
</code></pre><h2 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h2><p>报告中一共包含23中单独的因子。每一个小节包括了一个定义的时间段内每个因子的表现。</p>
<p>为了计算每一个单独因子的对应回报率，将会创建一个单因子投资组合。为了创造这个单因子投资组合，在选择的区域中的实体证券根据一个单独的实体因子被降序排列。 </p>
<p>在一个日历月最开始时，我们从这个排序的列表中选择证券并且不断累积直到积累的市场份额达到全部的地区的市场份额的50%来作为我们的单因子投资组合。然后我们将会持有这些证券直到这个日历月最后。这一个月的单因子投资组合然后会被用来和整个市场进行比较。  </p>
<p>同样的构建过程在每个月都会进行，并且这个连续不断的每月回报率会被联系到一起来提供一个积累因子表现来衡量不同的时间帧。<br>这个过程被不断的重复只是使用不同的因子并且这些结果被聚合在一起。应用这个一致的过程可以来比较因子间的超额表现活underperformance在同一个区域间。  </p>
<p><strong>关于调整（Adjustments）</strong><br>一个区域表示一个国家比如美国，在产业证券级别市场和基础数据被使用了 sector-average 相关数据调整了。<br>对于区域代表多个国家的，比如Asia Pacific，市场和基础数据也被调整了通过行业和国家来调整（Country and Sector Adjusted）。  </p>
<h2 id="因子定义"><a href="#因子定义" class="headerlink" title="因子定义"></a>因子定义</h2><table>
<thead>
<tr>
<th>价值因子</th>
<th>收益率因子</th>
<th>增长因子</th>
<th>质量因子</th>
<th>大小因子</th>
<th>波动因子</th>
<th>动量因子</th>
</tr>
</thead>
<tbody>
<tr>
<td> Book to Price(市净率)</td>
<td>Dividend Yield(股息收益率)</td>
<td>Earnings Growth 5Y(五年盈利增长)</td>
<td>Return on Equity(股东权益回报率)</td>
<td>Market Cap (市值)</td>
<td>Market Beta(市场Beta值)</td>
<td>Momentum ST()</td>
</tr>
<tr>
<td> Earning Yield(收益率)</td>
<td>Shareholder Yield(股东收益率)</td>
<td>Sales Growth 5Y(五年销售增长)</td>
<td>Net Profit Margin(净利润率)</td>
<td></td>
<td>Daily Volatility 1Y(1年日均波动率)</td>
<td>Momentum 12-1()</td>
</tr>
<tr>
<td> Cash Flow Yield(现金流量收益率)</td>
<td></td>
<td>Forecast Growth 12M(12月预测增长率)</td>
<td>Low Gearing (低资本负债比率)</td>
<td></td>
<td>Volatility 3Y(3年波动率)</td>
<td>Forecast 12M Revisions(预测12月的反转)</td>
</tr>
<tr>
<td> Sales to Price(市销率)</td>
<td></td>
<td>Dividend Growth 5Y(5年股息增长)</td>
<td>Earnings Growth Stability(收益增长稳定性)</td>
<td></td>
</tr>
<tr>
<td> EBITA to EV(企业倍数估值)</td>
<td></td>
<td></td>
<td>Sales Growth Stability(销售增长稳定性)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="价值因子"><a href="#价值因子" class="headerlink" title="价值因子"></a>价值因子</h2><h3 id="Book-to-Price-市净率"><a href="#Book-to-Price-市净率" class="headerlink" title="Book to Price(市净率)"></a>Book to Price(市净率)</h3><pre><code>The ratio of the company’s book value (the sum of shareholders’ equity plus accumulated retained earnings from the P &amp; L Account) to its share price.

This factor has been one of the most successful measures of the intrinsic value of company shares. 
</code></pre><p>市净率等于这个公司的账本价值(股东权益与保证金账户累计留存收益之和)／股票价格<br><em>这个因子是最有效的衡量这个公司股票的原始价值的方法。</em></p>
<h4 id="RiceQuant-字段及获取方法"><a href="#RiceQuant-字段及获取方法" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：pe_ratio</strong><br>代码</p>
<pre><code>dp = get_fundamentals(query(fundamentals.eod_derivative_indicator.pe_ratio).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2018-08-01&apos;,&apos;4q&apos; ,report_quarter = True)
dp.minor_xs(&apos;000001.XSHE&apos;)
report_quarter pe_ratio
2018-08-01         2018q1   6.5443
2018-04-27         2018q1   7.9041
2018-01-26         2017q3  10.4034
2017-10-26         2017q3   8.3344
</code></pre><h3 id="Earning-Yield-收益率"><a href="#Earning-Yield-收益率" class="headerlink" title="Earning Yield(收益率)"></a>Earning Yield(收益率)</h3><pre><code>Annual earnings (adjusted for amortizations of intangibles, extraordinary charges and credits) per share divided by the share price.

This factor measures the worth of a company’s shares according to the company’s ability to support each share with after tax earnings.
</code></pre><p>每一股年收益除以每一股的价格。<br><em>这个因子用于衡量一个公司的股票通过公司税后每一股可以赚多少</em></p>
<h4 id="RiceQuant-字段及获取方法-1"><a href="#RiceQuant-字段及获取方法-1" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>earnings_per_share</code></strong><br>说明： 基本每股收益<br>指企业应当按照属于普通股股东的当期净利润<br>除以发行在外普通股的加权平均数从而计算出的每股收益<br><strong>代码：</strong> </p>
<pre><code>dp = get_fundamentals(query(fundamentals.financial_indicator.earnings_per_share).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2018-08-01&apos;,&apos;4q&apos; ,report_quarter = True)
dp.minor_xs(&apos;000001.XSHE&apos;)
 report_quarter earnings_per_share
2018-08-01         2018q1               0.33
2018-04-27         2018q1               0.33
2018-01-26         2017q3               1.06
2017-10-26         2017q3               1.06
</code></pre><h3 id="Cash-Flow-Yield-现金流量收益率"><a href="#Cash-Flow-Yield-现金流量收益率" class="headerlink" title="Cash Flow Yield(现金流量收益率)"></a>Cash Flow Yield(现金流量收益率)</h3><pre><code>Annual cash flow per share divided by the share price.

This factor is related to earnings yield but also includes other items, 
specifically: depreciation, amortizations, and provisions for deferred 
liabilities. It is intended to capture the cash availability of the 
company as a multiple of the share price, and offers a value criteria 
based on the stream of accessible cash earnings
</code></pre><p>每一股的年现金流除以每一股的价格<br><em>这个因子和回报收益率有关同时也包含了其他的东西，明确的：货币贬值， 摊销 以及延期债务的规定。这个因子试图抓取公司的现金可用性作为股票的倍数，同时提供一个基于可以获得的现金收入流价值标准</em></p>
<h4 id="RiceQuant-字段及获取方法-2"><a href="#RiceQuant-字段及获取方法-2" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>1/pcf_ratio</code></strong><br>说明： 市现率： 市现率是股票价格与每股现金流量的比率，所以在这里我需要获取的是这个pcf_ratio的倒数才是年现金流除以每一股的价格。<br>总市值/去年经营现金流量净额</p>
<p><strong>代码：</strong> </p>
<pre><code>dp = get_fundamentals(query(fundamentals.eod_derivative_indicator.pcf_ratio).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2018-08-01&apos;,&apos;4q&apos; ,report_quarter = True)

dp.minor_xs(&apos;000001.XSHE&apos;)

report_quarter pcf_ratio
2018-08-01         2018q1   -1.3227
2018-04-27         2018q1   -1.5684
2018-01-26         2017q3    -2.031
2017-10-26         2017q3   17.4689
</code></pre><h3 id="Sales-to-Price-市销率"><a href="#Sales-to-Price-市销率" class="headerlink" title="Sales to Price(市销率)"></a>Sales to Price(市销率)</h3><pre><code>Net sales per share divided by the share price.
This factor measures the worth of a company’s shares according to the annual sales volume supporting the company business. The item is considered by many analysts to be less susceptible to manipulation than other valuation criteria; it is however, a less comprehensive measure of a company’s range of activities.
</code></pre><p>每一股的净销售额除以每一股的价格<br><em>这个因子通过年销售量来衡量这个公司的价值。这个因子被很多的分析师认为更加不容易操纵比起其他的因子；无论如何这是一个不很复杂的衡量一个公司活动范围的方式。</em></p>
<h4 id="RiceQuant-字段及获取方法-3"><a href="#RiceQuant-字段及获取方法-3" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>1/ps_ratio</code></strong><br>说明： 市销率： 市销率为股票价格与每股销售收入之比，市销率越小，通常被认为投资价值越高，所以在这里我需要获取的是这个ps_ratio的倒数才是每一股的净销售额除以每一股的价格。   </p>
<p><strong>代码：</strong> </p>
<pre><code>dp = get_fundamentals(query(fundamentals.eod_derivative_indicator.ps_ratio).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2017-12-31&apos;,&apos;4q&apos; ,report_quarter = True)

dp.minor_xs(&apos;000001.XSHE&apos;)
report_quarter ps_ratio
2017-12-29         2017q3   2.1629
2017-09-29         2017q2   1.7825
2017-06-29         2017q1   1.5004
2017-03-29         2016q4   1.4521    
</code></pre><h3 id="EBITA-to-EV-企业倍数估值"><a href="#EBITA-to-EV-企业倍数估值" class="headerlink" title="EBITA to EV(企业倍数估值)"></a>EBITA to EV(企业倍数估值)</h3><pre><code>The ratio of the company&apos;s EBITDA to Enterprise Value. EBITDA is Earnings before interest, taxes and depreciation and is calculated by taking the pretax income and adding back interest expense on debt and depreciation, depletion and amortization and subtracting interest capitalized.
Enterprise Value is defined as &quot;market capitalization + total debt + preferred stock - cash and cash equivalents&quot;.
</code></pre><p>这是EBITDA对企业价值的比率。EBITDA 是在利息，税以及货币贬值之前的收益，通过考虑税前收入和增加债务和折旧，消耗和摊销以及减去利息资本化的利息费用加回来计算出来的。<br>企业价值被定义为“市场价值 + 全部债务 + 优先股-现金和现金等价物”  </p>
<h4 id="RiceQuant-字段及获取方法-4"><a href="#RiceQuant-字段及获取方法-4" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>1/ev_to_ebitda</code></strong><br>说明： 企业倍数： 评估公司价值的指标，看的出来，这里也是刚好是导数才能和上一致。<br><em>我有一个问题，EV是怎么计算出来的。</em><br><strong>这个字段无法查出，ev是有值的而ebitda为NA，暂时无法确定是否其他的股票也没有值</strong></p>
<p><strong>代码：</strong> </p>
<pre><code>dp = get_fundamentals(query(fundamentals.financial_indicator.ev_to_ebitda).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2017-12-31&apos;,&apos;4q&apos; ,report_quarter = True)

dp.minor_xs(&apos;000001.XSHE&apos;)
report_quarter ev_to_ebitda
2017-12-29         2017q3          NaN
2017-09-29         2017q2          NaN
2017-06-29         2017q1          NaN
2017-03-29         2016q4          NaN
</code></pre><h2 id="收益率因子"><a href="#收益率因子" class="headerlink" title="收益率因子"></a>收益率因子</h2><h3 id="Dividend-Yield-股息收益率"><a href="#Dividend-Yield-股息收益率" class="headerlink" title="Dividend Yield(股息收益率)"></a>Dividend Yield(股息收益率)</h3><pre><code>The annual dividend paid per share divided by the share price.
This factor measures the value of company shares according to the stream of dividend income resulting from share ownership.
</code></pre><p>一年每一股的股息除以每股的价格 </p>
<h4 id="RiceQuant-字段及获取方法-5"><a href="#RiceQuant-字段及获取方法-5" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><em>这个因子通过股权所得的股息收入流衡量了公司股票价格</em><br><strong>字段：<code>dividend_yield</code></strong><br>说明： 股息率： 股息率是股息与股票价格之间的比率<br>股息率＝∑每股股利(税前) / 每股市价</p>
<p><strong>代码：</strong> </p>
<pre><code>dp = get_fundamentals(query(fundamentals.eod_derivative_indicator.dividend_yield).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2017-12-31&apos;,&apos;4q&apos; ,report_quarter = True)
dp.minor_xs(&apos;000001.XSHE&apos;)
report_quarter dividend_yield
2017-12-29         2017q3          1.188
2017-09-29         2017q2         1.4221
2017-06-29         2017q1            NaN
2017-03-29         2016q4         1.3996
</code></pre><h3 id="Shareholder-Yield-股东收益率"><a href="#Shareholder-Yield-股东收益率" class="headerlink" title="Shareholder Yield(股东收益率)"></a>Shareholder Yield(股东收益率)</h3><pre><code>The sum of Net Buyback Yield, Dividend Yield and Net Debt Paydown Yield.
This factor measures the proportion of a company&apos;s value distributed to shareholders through dividend payments, share repurchases and debt reduction.
</code></pre><p>净回购收益率的总和除以收益率和净债务部分还款收益率<br><em>这个因子衡量了公司通过股息分红，股票再回购和债务减少分配给股东公司价值的比率</em></p>
<h2 id="增长因子"><a href="#增长因子" class="headerlink" title="增长因子"></a>增长因子</h2><h3 id="Earnings-Growth-5Y-五年盈利增长"><a href="#Earnings-Growth-5Y-五年盈利增长" class="headerlink" title="Earnings Growth 5Y(五年盈利增长)"></a>Earnings Growth 5Y(五年盈利增长)</h3><pre><code>The average annual growth rate of earnings (adjusted for amortizations of intangibles, extraordinary charges and credits) over a trailing five years.
Earnings Growth is, perhaps, the clearest of the growth criteria. However, it is subject to the distortions of reporting conventions and manipulation and, particularly in some markets, only known after a considerable lag.
</code></pre><p>过去五年的平均年收入增长率（根据无形资产摊销，特殊费用和信贷调整。<br>盈利增长可能是最清晰的增长标准。然而他会收到报告惯例失真和操控，特别是在一些市场上，只有在一段时间后才能看出来。  </p>
<h4 id="RiceQuant-字段及获取方法-6"><a href="#RiceQuant-字段及获取方法-6" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>profit_from_operation</code></strong><br>说明： 可以获取每年的营业利润，然后计算五年的平均增长情况<br>营业利润： 企业在其全部销售业务中实现的利润，又称营业利润、经营利润，它包含主营业务利润</p>
<pre><code>年增长率是当年利润的较前一年的增长量除以前一年利润的百分比.
平均增长率的计算：
假定
1、平均增长率为X
2、每年的增长率分别为R1、R2、R3,...,Rn
则：
X＝{[（1＋R1）＊（1＋R2）＊（1＋R3）＊...*(1+Rn)]^1/n} - 1
注：^1/n表示开n次方
</code></pre><p><a href="https://www.zybang.com/question/cc63fc27473ec333c407161c3e2089d6.html" target="_blank" rel="noopener">https://www.zybang.com/question/cc63fc27473ec333c407161c3e2089d6.html</a><br><strong>代码：</strong> </p>
<pre><code>import math
dp = get_fundamentals(query(fundamentals.income_statement. profit_from_operation).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2018-01-10&apos;, &apos;5y&apos;)
dp2 = get_fundamentals(query(fundamentals.income_statement. profit_from_operation).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2017-01-10&apos;, &apos;5y&apos;)
upPercent = dp.minor_xs(&apos;000001.XSHE&apos;)[&apos;profit_from_operation&apos;].values/dp2.minor_xs(&apos;000001.XSHE&apos;)[&apos;profit_from_operation&apos;].values
i = 1
for i in range(len(upPercent)):
    i = i*(upPercent[i] + 1)

earning_growth_5y = math.pow(i, 1/5.0) - 1    
</code></pre><h3 id="Sales-Growth-5Y-五年销售增长"><a href="#Sales-Growth-5Y-五年销售增长" class="headerlink" title="Sales Growth 5Y(五年销售增长)"></a>Sales Growth 5Y(五年销售增长)</h3><pre><code>The average annual growth rate of net sales per share over a trailing five years.
Although growth in sales per share might be only a narrow measure of a company’s business growth, and may be subject to a number of distortions, it is less subject to differences in reporting conventions or manipulation than many other balance sheet or profit and loss items.
</code></pre><p>过去五年的每股净销售量平均年增长率。<br>尽管每股增长率也许只是衡量公司业务增长的一个小范围，并且可能有一些扭曲，与许多其他资产负债表或损益项目相比，它在报告惯例或操纵方面的差异较小。</p>
<h4 id="RiceQuant-字段及获取方法-7"><a href="#RiceQuant-字段及获取方法-7" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>revenue</code></strong><br>说明： 可以获取每年的收入，然后计算五年的盈利增长情况</p>
<pre><code>年增长率是当年利润的较前一年的增长量除以前一年利润的百分比.
平均增长率的计算：
假定
1、平均增长率为X
2、每年的增长率分别为R1、R2、R3,...,Rn
则：
X＝{[（1＋R1）＊（1＋R2）＊（1＋R3）＊...*(1+Rn)]^1/n} - 1
注：^1/n表示开n次方
</code></pre><p><a href="https://www.zybang.com/question/cc63fc27473ec333c407161c3e2089d6.html" target="_blank" rel="noopener">https://www.zybang.com/question/cc63fc27473ec333c407161c3e2089d6.html</a><br><strong>代码：</strong> </p>
<pre><code>import math
dp = get_fundamentals(query(fundamentals.income_statement.revenue).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2018-01-10&apos;, &apos;5y&apos;)
dp2 = get_fundamentals(query(fundamentals.income_statement.revenue).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2017-01-10&apos;, &apos;5y&apos;)
upPercent = dp.minor_xs(&apos;000001.XSHE&apos;)[&apos;revenue&apos;].values/dp2.minor_xs(&apos;000001.XSHE&apos;)[&apos;revenue&apos;].values
i = 1
for i in range(len(upPercent)):
    i = i*(upPercent[i] + 1)

revenue_growth_5y = math.pow(i, 1/5.0) - 1
</code></pre><h3 id="Forecast-Growth-12M-12月预测增长率"><a href="#Forecast-Growth-12M-12月预测增长率" class="headerlink" title="Forecast Growth 12M(12月预测增长率)"></a>Forecast Growth 12M(12月预测增长率)</h3><pre><code>Consensus forecast growth of earnings over the next 12 months. The 12 month growth is calculated on a pro-rata basis from the forecasts for each of the company&apos;s next 2 annual reporting periods.
</code></pre><p>市场普遍预测未来12个月的盈利增长。 12个月的增长是根据公司未来2个年度报告期的预测按比例计算的。</p>
<h3 id="Dividend-Growth-5Y-5年股息增长"><a href="#Dividend-Growth-5Y-5年股息增长" class="headerlink" title="Dividend Growth 5Y(5年股息增长)"></a>Dividend Growth 5Y(5年股息增长)</h3><pre><code>The average annual growth rate of dividends over a trailing five years.
</code></pre><p>过去五年平均股息年增长率</p>
<h4 id="RiceQuant-字段及获取方法-8"><a href="#RiceQuant-字段及获取方法-8" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>dividend_yield</code></strong><br>说明：股息率是股息与股票价格之间的比率；股息率＝∑每股股利(税前) / 每股市价<br>由于股息不是每年都会分配的，很多股票不是每年都有股息的。所以目前只是简单的写出怎么获取一年的股息率。但是怎么计算这个因子还未完成。<br><strong>代码：</strong> </p>
<pre><code>## 获取股息率
fundamental_df = get_fundamentals(query(fundamentals.eod_derivative_indicator.dividend_yield).order_by(fundamentals.eod_derivative_indicator.dividend_yield.desc()).limit(50), &apos;2018-01-10&apos;, &apos;1y&apos;)

for key in fundamental_df.minor_axis:
    print key
    print fundamental_df.minor_xs(key)
</code></pre><h2 id="质量因子"><a href="#质量因子" class="headerlink" title="质量因子"></a>质量因子</h2><h3 id="Return-on-Equity-股东权益回报率"><a href="#Return-on-Equity-股东权益回报率" class="headerlink" title="Return on Equity(股东权益回报率)"></a>Return on Equity(股东权益回报率)</h3><pre><code>Net Income after preferred dividends divided by the book value of shareholders’ common equity.
RoE measures the profitability of the operations of the company as a proportion of the total amount of equity in the company. Since RoE multiplied by the reinvestment rate (the proportion of earnings not paid as dividends but reinvested in the company) gives the warranted growth rate of a company, RoE is a traditional measure of a company&apos;s growth potential.
</code></pre><p>优先股股息后的净收入除以股东普通股权的账面价值<br>RoE衡量了这个公司的操作的利润率作为这个公司全部数量产权的一部分。由于RoE乘了再投资率（盈利没有用来作为股息支付而是再次投向公司）给出了公司的保证增长率，RoE是一个传统的用来衡量公司增长潜力的因子。</p>
<h4 id="RiceQuant-字段及获取方法-9"><a href="#RiceQuant-字段及获取方法-9" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>roe</code></strong><br>说明：净资产收益率(摊薄)(%)  </p>
<p><strong>代码：</strong><br>    <a href="https://www.ricequant.com/api/research/chn#research-API-current_performance" target="_blank" rel="noopener">https://www.ricequant.com/api/research/chn#research-API-current_performance</a></p>
<pre><code>## 获取股息率  
current_performance(&apos;000004.XSHE&apos;,quarter=&apos;2017q2&apos;,fields=&apos;roe&apos;,interval=&apos;6q&apos;)
    end_date  info_date        roe
0 2015-12-31 2016-04-15   1.529771
1 2014-12-31 2015-04-16   4.735392
2 2013-12-31 2014-04-15  -1.642598
3 2012-12-31 2013-04-13   2.588968
4 2007-12-31 2008-04-15 -13.200000
</code></pre><h3 id="Net-Profit-Margin-净利润率"><a href="#Net-Profit-Margin-净利润率" class="headerlink" title="Net Profit Margin(净利润率)"></a>Net Profit Margin(净利润率)</h3><pre><code>The &quot;net margin&quot;, annual net income before preferred dividends (plus policyholders&apos; surplus for insurance companies), divided by annual net sales.
This measure attempts to assess the company&apos;s potential for profitable, sustained expansion or growth.
</code></pre><p>“净利润率”，优先股股息之前的年度净收入（加上保险公司的保单持有人盈余）除以年度净销售额。<br>这个因子试图评估这个公司利润潜力，持续扩张或者增长。</p>
<h4 id="RiceQuant-字段及获取方法-10"><a href="#RiceQuant-字段及获取方法-10" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>net_profit_to_total_operating_revenueTTM</code></strong><br>说明：净利润率;含少数股东损益的净利润（TTM）/营业收入（TTM）*100%<br><strong>代码：</strong>  </p>
<pre><code>dp = get_fundamentals(query(fundamentals.financial_indicator_TTM.net_profit_to_total_operating_revenueTTM).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2018-01-10&apos;, &apos;5y&apos;)
dp.minor_xs(&apos;000001.XSHE&apos;)
                         net_profit_to_total_operating_revenueTTM
2018-01-10                                  21.8157
2017-01-10                                  21.3537
2016-01-08                                  24.3004
2015-01-08                                  27.6696
2014-01-08                                   31.247
dp.minor_xs(&apos;000001.XSHE&apos;)* (-1)
                 debt_to_asset_ratio
2018-01-10            -93.0482
2017-01-10            -92.8982
2016-01-08            -93.9541
2015-01-08            -94.0898
2014-01-08            -94.8851
</code></pre><h3 id="Low-Gearing-低资本负债比率"><a href="#Low-Gearing-低资本负债比率" class="headerlink" title="Low Gearing (低资本负债比率)"></a>Low Gearing (低资本负债比率)</h3><pre><code>The negative of debt to equity. Low geared companies can regarded as being of higher &quot;quality&quot; as they are less burdened by debt repayment costs.
</code></pre><p>债务对股权的负面影响。低资本负载率比的公司可以被认为是高“质量”的因为它们的债务偿还成本负担更小。  </p>
<h4 id="RiceQuant-字段及获取方法-11"><a href="#RiceQuant-字段及获取方法-11" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>debt_to_asset_ratio</code></strong><br>说明：资产负债率： 资产负债率是企业负债总额占企业资产总额的百分比<br><strong>代码：</strong> </p>
<pre><code>dp = get_fundamentals(query(fundamentals.financial_indicator_TTM.net_profit_to_total_operating_revenueTTM).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2018-01-10&apos;, &apos;5y&apos;)

dp.minor_xs(&apos;000001.XSHE&apos;) 
               debt_to_asset_ratio
2018-01-10             93.0482
2017-01-10             92.8982
2016-01-08             93.9541
2015-01-08             94.0898
2014-01-08             94.8851

dp.minor_xs(&apos;000001.XSHE&apos;)*(-1)
            debt_to_asset_ratio
2018-01-10            -93.0482
2017-01-10            -92.8982
2016-01-08            -93.9541
2015-01-08            -94.0898
2014-01-08            -94.8851
</code></pre><h3 id="Earnings-Growth-Stability-收益增长稳定性"><a href="#Earnings-Growth-Stability-收益增长稳定性" class="headerlink" title="Earnings Growth Stability(收益增长稳定性)"></a>Earnings Growth Stability(收益增长稳定性)</h3><pre><code>This &apos;quality&apos; factor is calculated as the negative of the standard deviation of earnings growth over the most recent 3 years of growth data.
</code></pre><p>这个“质量”因素计算为最近3年增长数据中收益增长标准差的负值。</p>
<h4 id="RiceQuant-字段及获取方法-12"><a href="#RiceQuant-字段及获取方法-12" class="headerlink" title="RiceQuant 字段及获取方法"></a>RiceQuant 字段及获取方法</h4><p><strong>字段：<code>inc_gross_profit</code></strong><br>说明：营业利润(同比增长率)<br><strong>代码：</strong> </p>
<pre><code>dp = get_fundamentals(query(fundamentals.financial_indicator.inc_gross_profit).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2018-01-10&apos;, &apos;3y&apos;)

-dp.minor_xs(&apos;000001.XSHE&apos;).std()
inc_gross_profit   -5.265935
dtype: float64
</code></pre><h3 id="Sales-Growth-Stability-销售增长稳定性"><a href="#Sales-Growth-Stability-销售增长稳定性" class="headerlink" title="Sales Growth Stability(销售增长稳定性)"></a>Sales Growth Stability(销售增长稳定性)</h3><pre><code>This &apos;Quality&apos; factor is calculated as the negative of the standard deviation of Sales Growth over the most recent 3 years of growth data.
</code></pre><p>此“质量”因子计算为销售增长标准差与最近3年增长数据的负值。</p>
<h4 id="RiceQuant-相关字段及获取方法"><a href="#RiceQuant-相关字段及获取方法" class="headerlink" title="RiceQuant 相关字段及获取方法"></a>RiceQuant 相关字段及获取方法</h4><p><strong>字段：<code>inc_revenue</code></strong><br>说明：营业总收入(同比增长率)<br><strong>代码：</strong> </p>
<pre><code>dp = get_fundamentals(query(fundamentals.financial_indicator. inc_revenue).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2018-01-10&apos;, &apos;3y&apos;)

dp.minor_xs(&apos;000001.XSHE&apos;)
                inc_revenue
2018-01-10     -2.6047
2017-01-10     15.2013
2016-01-08     30.1934

-dp.minor_xs(&apos;000001.XSHE&apos;).std()
inc_revenue   -16.419156
dtype: float64
</code></pre><h2 id="大小因子"><a href="#大小因子" class="headerlink" title="大小因子"></a>大小因子</h2><h3 id="市场价值"><a href="#市场价值" class="headerlink" title="市场价值"></a>市场价值</h3><pre><code>The market capitalization of the stock.
The average size statistic of a portfolio is the weighted (by holding value) average size of the securities held. The average size statistic of a benchmark (or total market) is the weighted (by holding value) average size of the securities within the benchmark (or total market)
</code></pre><p>股票的市场价值<br>一个投资组合的平均规模统计是持有的证券的平均规模加权（通过持有的价值）。这个基准（或者总市场）的平均规模统计是基准中股票平均规模加权（通过持有价值）。</p>
<h2 id="波动率因子"><a href="#波动率因子" class="headerlink" title="波动率因子"></a>波动率因子</h2><h3 id="Market-Beta-市场Beta值"><a href="#Market-Beta-市场Beta值" class="headerlink" title="Market Beta(市场Beta值)"></a>Market Beta(市场Beta值)</h3><pre><code>The &quot;slope coefficient&quot;, (β), from the simple regression:
Security monthly return = α + β * market monthly return + random error.
The regression is carried out over 36 month periods. Where sufficient information is not available, β=1 is assumed.
</code></pre><p>斜率因子（β）是从一个简单的回归：<br>股票月的回归率 = α + β * 市场月回归率 + 随机误差<br>回归会进行过去36个月。当没有明显的信息的时候，是假设β=1。  </p>
<h4 id="RiceQuant-相关字段及获取方法-1"><a href="#RiceQuant-相关字段及获取方法-1" class="headerlink" title="RiceQuant 相关字段及获取方法"></a>RiceQuant 相关字段及获取方法</h4><p><strong>字段：<code>inc_revenue</code></strong><br>说明：营业总收入(同比增长率)<br><strong>代码：</strong> </p>
<pre><code>dp = get_fundamentals(query(fundamentals.financial_indicator. inc_revenue).filter(fundamentals.stockcode == &apos;000001.XSHE&apos;), &apos;2018-01-10&apos;, &apos;3y&apos;)

dp.minor_xs(&apos;000001.XSHE&apos;)
                inc_revenue
2018-01-10     -2.6047
2017-01-10     15.2013
2016-01-08     30.1934

-dp.minor_xs(&apos;000001.XSHE&apos;).std()
inc_revenue   -16.419156
dtype: float64
</code></pre><h3 id="Daily-Volatility-1Y-1年日均波动率"><a href="#Daily-Volatility-1Y-1年日均波动率" class="headerlink" title="Daily Volatility 1Y(1年日均波动率)"></a>Daily Volatility 1Y(1年日均波动率)</h3><pre><code>The standard deviation of the last year of daily total returns, expressed as an annualized percentage.
</code></pre><p>每日总回报的去年的标准差，以年化百分比表示。</p>
<h3 id="Volatility-3Y-3年波动率"><a href="#Volatility-3Y-3年波动率" class="headerlink" title="Volatility 3Y(3年波动率)"></a>Volatility 3Y(3年波动率)</h3><pre><code>The standard deviation of the last 36 months of total returns, expressed as an annualized percentage.
</code></pre><p>过去36个月的总回报率的标准差，以年化百分比表示。</p>
<h2 id="动量因子"><a href="#动量因子" class="headerlink" title="动量因子"></a>动量因子</h2><h3 id="Momentum-ST"><a href="#Momentum-ST" class="headerlink" title="Momentum ST"></a>Momentum ST</h3><pre><code>Calculated using a 6 month &quot;memory&quot; of monthly total returns. The past period returns are weighted using a &quot;decay ratio&quot; of 2/3, per month. This weighted historic return factor measures the degree of performance trend following. It is useful in recognizing trading character of specific markets and in noticing occasional changing patterns through the market cycle.
</code></pre><p>使用每月总回报的6个月“记忆”计算。 过去的期间回报使用每月2/3的“衰减率”加权。 该加权历史回报因子衡量了追随的业绩趋势程度。 它有助于识别特定市场的交易特征，并注意到市场周期中偶尔会出现的变化模式。</p>
<h3 id="Momentum-12-1"><a href="#Momentum-12-1" class="headerlink" title="Momentum 12-1"></a>Momentum 12-1</h3><pre><code>The total return of the stock over the last 12 months, excluding the total return over the most recent month since reversal effects are often associated with one-month returns.
</code></pre><p>过去12个月的股票总回报，不包括自逆转影响以来最近一个月的总回报，通常与一个月的回报相关。</p>
<h3 id="Forecast-12M-Revisions"><a href="#Forecast-12M-Revisions" class="headerlink" title="Forecast 12M Revisions"></a>Forecast 12M Revisions</h3><pre><code>IBES balance of Earnings forecast revisions for the over the next 12 months.
Calculated as the difference between the number of upwards revisions minus the number of downwards revisions (as sampled over the past 1M period), expressed as a percentage of the number of estimates.
</code></pre><p>IBES未来12个月的盈利预测修正余额。<br>计算为向上修订数量减去向下修订数量（在过去1M期间采样）之间的差异，表示为估计数量的百分比。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.sevenpan.com/2018/09/21/Algo/单因子说明以及计算结果/" data-id="cjswzmq08000446rrm539iaw4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Algo/跟踪聪明钱" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/04/Algo/跟踪聪明钱/" class="article-date">
  <time datetime="2018-09-04T12:16:20.000Z" itemprop="datePublished">2018-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="跟踪聪明钱"><a href="#跟踪聪明钱" class="headerlink" title="跟踪聪明钱"></a>跟踪聪明钱</h1><p>##研究目标<br>分钟行情数据进行研究  </p>
<p>##聪明度指标S<br>聪明钱情绪因子Q，因子Q越高，表面聪明钱的交易倾向于出现在价格较高处，逢高出货的表现，表明了悲观态度；因子Q值越小，表明聪明钱交易出现在价格较低处，逢低吸筹的表现，反应了乐观情绪。<br>Q 值小视为聪明钱逢低买入的表现，因此可选取五分组中Q值最小的第一组，作为跟踪聪明钱动向的 SMART 组合</p>
<p>##从分钟行情数据中看聪明钱<br>股票的分钟行情数据，包含开盘价，最高价，最低价，收盘价和成交量等。<br>找聪明钱的特征设置为：“单笔订单数量更大，订单报价更为激进”。<br>使用如下的指标来衡量每一分钟交易聪明程度：</p>
<p>$$ S_t = |R_t|/V_t^{0.5}$$</p>
<p>其中\(R_t\) 是第t分钟的涨跌幅，\(V_t\)是第t分钟的成交量。指标\(S_t\)的值越大，则该分钟的交易越聪明。<br>对于特定的时段，特定股票的所有分钟行情数据， 将其按指标S从大到小排序，成交量累积占比前20%的视为聪明钱交易。 —- 这里我有点不懂是怎么处理的？<br>懂了，就是对每一分钟的S值进行排序，然后只取成交值为20%的时间做为聪明钱的交易。<br><strong>聪明钱情绪因子Q</strong><br>$$ Q = VWAP_{smart}/VWAP_{all}$$<br>\( VWAP_{smart}\) 是聪明钱的成交量加权平均价<br>\( VWAP_{all}\) 是所有交易的成交量加权平均价<br>Q反应了这个时间段<strong>我的问题是这个时间段怎么定义的？</strong>中聪明钱参与交易的相对价位。<br>Q越高，值越大，聪明钱的交易越倾向于出现在价格高点，逢高出货。<br>Q越低，值越小，聪明钱的交易越倾向于出现在价格低点，逢低吸筹。  </p>
<h2 id="情绪因子Q的选股能力"><a href="#情绪因子Q的选股能力" class="headerlink" title="情绪因子Q的选股能力"></a>情绪因子Q的选股能力</h2><p>每个月的最后一个交易日，计算所有股票最近10个交易日的分钟行情数据，计算每个股票的情绪因子Q。<br>然后考虑了每个月因子值和次月收益的秩相关系数（RankIC）<br>这个相关系数要怎么计算？ 次月收益是怎么得出来的？？<br>计算秩相关系数又是怎么计算的？  </p>
<p>投资的方法倒是看出来了：将市场上的股票按照Q从小到大排序，等分为五组。第一组为最小，第五组最大。然后可以最大和最小之间进行对冲<strong>为啥我觉得这么处理毫无逻辑</strong></p>
<p>##情绪因子的风险特征<br>重点关注情绪因子Q的市值，动量等因子的关联性。<br>使用横截面回归取残差的方式，对市值，动量，行业等因子进行剔除。横截面回归模型如下：<br>$$ Q_i = \beta_1LogMktVal + \beta_2Ret20d_i + \sum_{j=1}^{N} \beta_{3j}Ind_{ji} + \epsilon$$<br>其中，Q为情绪因子<br>LogMktVal 为股票对数流通市值<br>Ret20d 为前20个交易日的涨跌值<br>Ind申万一级行业哑变量<br>\( \epsilon\) 是残差因子  </p>
<p>##跟踪聪明钱的SMART组合<br>由于我们可以视Q值小为聪明钱逢低买入的表现。因此选取五分组中Q最小的第一组，用于跟踪聪明钱动向的SMART组合。</p>
<p>##除了上面描述的对冲计算收益率的方式我还感兴趣的地方</p>
<pre><code>1. 是否可以列出每次的聪明钱因子对应的股票，做一个股票集。
2. 还是没有看出来这里面是怎么根据q来进行投资组合的。
3. 后面的横截面回归模型是为什么？

实现完了优矿上的代码再来回答这些问题。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.sevenpan.com/2018/09/04/Algo/跟踪聪明钱/" data-id="cjswzmq06000346rrmxssypyy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SparkAndDeepLearning/Shuffle_翻译自spark_programming_guideline" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/23/SparkAndDeepLearning/Shuffle_翻译自spark_programming_guideline/" class="article-date">
  <time datetime="2018-04-23T10:17:04.000Z" itemprop="datePublished">2018-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/23/SparkAndDeepLearning/Shuffle_翻译自spark_programming_guideline/">Spark Programming--- Shuffle Operations 翻译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spark-Programming—-Shuffle-operations"><a href="#Spark-Programming—-Shuffle-operations" class="headerlink" title="Spark Programming— Shuffle operations"></a>Spark Programming— Shuffle operations</h1><p>original: <a href="http://spark.apache.org/docs/latest/rdd-programming-guide.html#shuffle-operations" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/rdd-programming-guide.html#shuffle-operations</a></p>
<p>一些spark的特定操作将会触发被称为shuffle的事件。Shuffle是Spark用于重新分布数据的机制，这样可以在不同的分区来分组。这通常涉及到在executor和机器之间进行拷贝数据，所以shuffle是一个很复杂并且消耗高的操作。  </p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为了了解shuffle期间发生了什么，我们可以考虑reduceByKey操作作为例子。reduceByKey操作生成了一个新的RDD通过所有的单个键值组合为一个元组-关键字和针对与该关键字相关的所有值执行reduce函数的结果。这里的挑战不是所有的值对一个单独的键都在同一个分区上或者甚至说在一台机器上，而是它们必须被重新分布来计算结果。<br>在Spark，数据通常不会跨分区分布到特定操作的必要位置。在计算中，一个单独的任务将会在一个单独的分区上操作-然而为了组织所有的数据来被一个的单独reduceByKey 的reduce任务来执行，Spark需要来执行一个all-to-all操作。它必须读取所有分区来找到所有键的值，然后将它们带到一起跨分区来为每一个键计算最终的结果—这个被称为shuffle。<br>尽管在每一个分区中的新的shuffled数据的元素集是很重要的，同样分区自己的顺序也很重要，而元素之间的顺序就不是了。如果一个想要预测shuffle中的顺序数据那么可以使用：  </p>
<ol>
<li>mapPartitions 来排序每一个分区，比如，.sorted</li>
<li>repartitionAndSortWithinPartitions 来有效分区同时同步重新分区。  </li>
<li>sortBy 创造一个全局的排序的RDD</li>
</ol>
<p>可以引起一个shuffle 的操作包括：repartition 和 coalesce,ByKey的操作，除了counting之外的比如：groupByKey 和reduceByKey,以及join操作比如cogroup 和 join。</p>
<h2 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h2><p>Shuffle是一个昂贵的操作因为它涉及到磁盘I/O，数据序列化和网络I/O。为了给shuffle组织数据，spark生成一系列任务-maps用于组织数据，以及一系列reduce任务来聚集它。这个命名系统来自于MapReduce而且并不直接和SparK的map，reduce操作有关。<br>在内部，单独的map任务的结果会被保存在内存中直到它们不适用。然后这些结果会被根据目标分区排序并且写向单一的文件。在reduce方面，任务读取相关的排序块。<br>一定的shuffle操作会消耗明显的数量的堆内存因为它们使用的是在内存中的数据结构来组织记录在传输之前或者之后。明显的，reduceByKey和AggregateByKey创造了这些结构在map阶段，以及 ‘Bykey的操作生成了它们在reduce阶段。当数据不能放进内存中时，Spark将会将这些表散落到硬盘中，会引起而外的磁盘I/O和增加垃圾回收次数。<br>Shuffle同样会生成大量的中间文件在磁盘中。从Spark1.3开始，这些文件被保存直到对应的RDDs不再被使用以及已经被垃圾回收了。这样做是为了shuffle文件不需要被重新创造如果lineage被重新计算时。垃圾回收也许会发生只有在一段很长时间，如果这个应用保留了对RDD的引用或者如果GC没有频繁的发生。这意味着长期运行的spark任务也许会消耗大量的磁盘空间。这个零时的磁盘目录会被spark.local.dir参数所指定。<br>Shuffle行为可以被调整通过一系列的参数。可以参考<a href="http://spark.apache.org/docs/latest/configuration.html#shuffle-behavior" target="_blank" rel="noopener"> Spark Configuration Guide.</a>‘Shuffle Behavior’章节。</p>
<h2 id="Shuffle-Behavior"><a href="#Shuffle-Behavior" class="headerlink" title="Shuffle Behavior"></a>Shuffle Behavior</h2><table>
<thead>
<tr>
<th>属性名称Property Name</th>
<th>默认值Default</th>
<th>含义Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>spark.reducer.maxSizeInFlight</td>
<td>48m</td>
<td>从每一个reduce任务中同步获取的map输出的最大值。由于每一个输出需要我们创造一个缓存来接受它，这个代表了每个任务的固定的内存开销，所以尽量保证它较小除非你有很多内存。</td>
<td></td>
</tr>
<tr>
<td>spark.reducer.maxReqsInFlight</td>
<td>Int.MaxValue</td>
<td>这个配置限制了任意给定点远程请求获取块数。当集群中的主机数量增加的时候，它也许会导致一个非常大数量的内部连接到一到多个节点，引起worker在负载下失败。通过允许它来限制获取请求的数量，这个情况也许会缓解</td>
<td></td>
</tr>
<tr>
<td>spark.reducer.maxBlocksInFlightPerAddress</td>
<td>Int.MaxValue</td>
<td>这个配置限制了每一个从给定端口里的的reduce任务可以获取的远程端口数量。当一个大量的block被一个给定的地址在一次单独获取或者同步获取所请求时，可能会冲垮服务的executor或者Node Manager。这个配置对于减少Node Manager的负载尤为有用当外部的shuffle是被允许的。你可以通过设定一个较低值来减轻这个情况。</td>
<td></td>
</tr>
<tr>
<td>spark.maxRemoteBlockSizeFetchToMem</td>
<td>Long.MaxValue</td>
<td>远程的块将会被获取到磁盘中，当这个块的大小超过了这个配置的值在byte单位上。这个用于避免一个巨大的请求占据了太多的内存。我们可以将这个配置为一个指定的值（比如，200M）。注意到这个配置将会影响到shuffle的获取以及远程块获取的块管理。对于允许了外部shuffle服务的用户，这个特性只会在外部shuffle服务版本高于Spark2。2时有效。</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.compress</td>
<td>true</td>
<td>是否压缩map的输出文件，通常是一个好想法。压缩将会使用spark.io.compression.codec.</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.file.buffer</td>
<td>32k</td>
<td>对每一个shuffle文件输出流的在内存中的缓存大小，单位是KiB除非有其他的特别指定。这些缓存减少了硬盘查找和系统调用创建中间shuffle文件的过程。</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.io.maxRetries</td>
<td>3</td>
<td>(Netty only)最大自动重复尝试的次数如果这个值没有被设置为0.这个重试逻辑有助于稳定大型的shuffle在长时间的GC暂停或者暂时的网络连接问题上。</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.io.numConnectionsPerPeer</td>
<td>1</td>
<td>(Netty only) 节点之间的连接的重复使用为了减少大型集群中重复建立连接的情况。对于有很多硬盘和很少主机的集群，这个将会导致并发行不足以饱和所有硬盘，因此用户可能会考虑增加这个值。</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.io.preferDirectBufs</td>
<td>true</td>
<td>(Netty only) 堆外缓冲区在shuffle和缓存块转移期间被用于减少垃圾回收。对于对外缓存内存数量有限的环境，用户也许想要关掉这个来强迫所有的来自于Netty的分配都是在堆上。</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.io.retryWait</td>
<td>5s</td>
<td>(Netty only) 在每一次重试直接需要等待多久。最大的延迟时间默认是15秒，maxRetries * retryWait.</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.service.enabled</td>
<td>false</td>
<td>允许外部shuffle服务。这个服务保存了通过executor所写的shuffle文件，这样这个executor可以安全的被移除。这个配置必须被允许如果spark.dynamicAllocation.enabled是“true”。这个外部的shuffle服务必须被启动。查看<a href="http://spark.apache.org/docs/latest/job-scheduling.html#configuration-and-setup" target="_blank" rel="noopener">dynamic allocation configuration and setup documentation </a>来获得更多信息。</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.service.port</td>
<td>7337</td>
<td>外部shuffle服务将会运行的端口。</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.service.index.cache.size</td>
<td>100m</td>
<td>缓存条目限制在指定的内存占用空间中，以字节为单位</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.maxChunksBeingTransferred</td>
<td>Long.MAX_VALUE</td>
<td>在shuffle服务中同一时间最大允许传输的块数量。注意到新来的连接将会被关闭如果达到了最大数量。这个客户端将会尝试重新连接根据shuffle的重试配置（see spark.shuffle.io.maxRetries and spark.shuffle.io.retryWait），如果这个限制也被达到了，那么这个任务将会失败。</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.sort.bypassMergeThreshold</td>
<td>200</td>
<td>(Advanced)在基于排序的shuffle管理中，避免合并排序数据如果这里没有map-side的聚合和这里最多有配置的这么多的reduce分区。</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.spill.compress</td>
<td>true</td>
<td>是否压缩溢出的数据在shuffle期间</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.accurateBlockThreshold</td>
<td>100 <em> 1024 </em> 1024</td>
<td>阀值是以bytes为单位，高于此值将准确记录HighlyCompressedMapStatus中的shuffle块的大小。这个用于帮助阻止OOM通过避免错误估计了shuffle块大小当获取了shuffle块时。</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.registration.timeout</td>
<td>5000</td>
<td>注册外部shuffle服务的超时时间，单位是毫秒</td>
<td></td>
</tr>
<tr>
<td>spark.shuffle.registration.maxAttempts</td>
<td>3</td>
<td>当注册外部shuffle服务失败的时候，我们会重复尝试的最大次数</td>
<td></td>
</tr>
<tr>
<td>spark.io.encryption.enabled</td>
<td>false</td>
<td>允许IO编码。目前支持所有的模式除了Mesos。当使用这个特性的时候，我们推荐RPC编码。</td>
<td></td>
</tr>
<tr>
<td>spark.io.encryption.keySizeBits</td>
<td>128</td>
<td>IO编码的值大小单位为bit。支持的值有128，192和256.</td>
<td></td>
</tr>
<tr>
<td>spark.io.encryption.keygen.algorithm</td>
<td>HmacSHA1</td>
<td>当生成一个IO编码键值时使用的算法。被支持的算法在Java Cryptography Architecture Standard Algorithm Name 文档的KeyGenerator章节中被描述。</td>
<td></td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.sevenpan.com/2018/04/23/SparkAndDeepLearning/Shuffle_翻译自spark_programming_guideline/" data-id="cjswzmq0m000e46rrviaut8ey" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algotrading-pyalgotrade/">Algotrading, pyalgotrade</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deeplearning4j-spark/">deeplearning4j; spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-git-nginx/">hexo,git,nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-git-nginx-ssh/">hexo,git,nginx,ssh,</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algotrading-pyalgotrade/" style="font-size: 10px;">Algotrading, pyalgotrade</a> <a href="/tags/deeplearning4j-spark/" style="font-size: 10px;">deeplearning4j; spark</a> <a href="/tags/hexo-git-nginx/" style="font-size: 10px;">hexo,git,nginx</a> <a href="/tags/hexo-git-nginx-ssh/" style="font-size: 10px;">hexo,git,nginx,ssh,</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/04/Core_java/Java8 并发指南：线程和执行者 Threads and Executors/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/03/基础建设和杂项比较/DevOps 笔记/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/22/基础建设和杂项比较/一台VPS所需要的安装/">一台VPS所需要的操作</a>
          </li>
        
          <li>
            <a href="/2018/11/23/基础建设和杂项比较/RPC,REST,SOAP/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/11/07/Algo/配对交易策略RQ/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Pan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>